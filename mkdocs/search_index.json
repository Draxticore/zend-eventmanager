{
    "docs": [
        {
            "location": "/",
            "text": "zend-eventmanager\n\n\n\n\n\n\nzend-eventmanager is designed for the following use cases:\n\n\n\n\nImplementing simple subject/observer patterns.\n\n\nImplementing Aspect-Oriented designs.\n\n\nImplementing event-driven architectures.\n\n\n\n\nThe basic architecture allows you to attach and detach listeners to named events,\nboth on a per-instance basis as well as via shared collections; trigger events;\nand interrupt execution of listeners.\n\n\n\n\nFile issues at https://github.com/zendframework/zend-eventmanager/issues\n\n\nDocumentation is at https://zendframework.github.io/zend-eventmanager/\n\n\n\n\nFor migration from version 2 to version 3, please \nread the migration\ndocumentation\n.\n\n\nBenchmarks\n\n\nWe provide scripts for benchmarking zend-eventmanager using the\n\nAthletic\n framework; these can be\nfound in the \nbenchmarks/\n directory.\n\n\nTo execute the benchmarks you can run the following command:\n\n\n$ vendor/bin/athletic -p benchmarks",
            "title": "Home"
        },
        {
            "location": "/#zend-eventmanager",
            "text": "zend-eventmanager is designed for the following use cases:   Implementing simple subject/observer patterns.  Implementing Aspect-Oriented designs.  Implementing event-driven architectures.   The basic architecture allows you to attach and detach listeners to named events,\nboth on a per-instance basis as well as via shared collections; trigger events;\nand interrupt execution of listeners.   File issues at https://github.com/zendframework/zend-eventmanager/issues  Documentation is at https://zendframework.github.io/zend-eventmanager/   For migration from version 2 to version 3, please  read the migration\ndocumentation .",
            "title": "zend-eventmanager"
        },
        {
            "location": "/#benchmarks",
            "text": "We provide scripts for benchmarking zend-eventmanager using the Athletic  framework; these can be\nfound in the  benchmarks/  directory.  To execute the benchmarks you can run the following command:  $ vendor/bin/athletic -p benchmarks",
            "title": "Benchmarks"
        },
        {
            "location": "/intro/",
            "text": "The EventManager: Overview\n\n\nzend-eventmanager is a component designed for the following use cases:\n\n\n\n\nImplementing simple subject/observer patterns.\n\n\nImplementing Aspect-Oriented designs.\n\n\nImplementing event-driven architectures.\n\n\n\n\nThe basic architecture allows you to attach and detach listeners to named\nevents, both on a per-instance basis as well as via shared collections; trigger\nevents; and interrupt execution of listeners.",
            "title": "Intro"
        },
        {
            "location": "/intro/#the-eventmanager-overview",
            "text": "zend-eventmanager is a component designed for the following use cases:   Implementing simple subject/observer patterns.  Implementing Aspect-Oriented designs.  Implementing event-driven architectures.   The basic architecture allows you to attach and detach listeners to named\nevents, both on a per-instance basis as well as via shared collections; trigger\nevents; and interrupt execution of listeners.",
            "title": "The EventManager: Overview"
        },
        {
            "location": "/quick-start/",
            "text": "Quick Start\n\n\nTypically, you will compose an \nEventManager\n instance in a class.\n\n\nuse Zend\\EventManager\\EventManagerInterface;\nuse Zend\\EventManager\\EventManager;\nuse Zend\\EventManager\\EventManagerAwareInterface;\n\nclass Foo implements EventManagerAwareInterface\n{\n    protected $events;\n\n    public function setEventManager(EventManagerInterface $events)\n    {\n        $events->setIdentifiers([\n            __CLASS__,\n            get_called_class(),\n        ]);\n        $this->events = $events;\n        return $this;\n    }\n\n    public function getEventManager()\n    {\n        if (null === $this->events) {\n            $this->setEventManager(new EventManager());\n        }\n        return $this->events;\n    }\n}\n\n\n\n\nThe above allows users to access the \nEventManager\n instance, or reset it with a\nnew instance; if one does not exist, it will be lazily instantiated on-demand.\n\n\nThe instance property \n$events\n is a convention for referring to the\nEventManager instance.\n\n\nAn \nEventManager\n is really only interesting if it triggers some events.\n\n\nBasic triggering via the \ntrigger()\n method takes three arguments:\n\n\n\n\nThe event \nname\n, which is usually the current function/method name;\n\n\nThe \ntarget\n, which is usually the current object instance;\n\n\nEvent \narguments\n, which are usually the arguments provided to the current function/method.\n\n\n\n\nclass Foo\n{\n    // ... assume events definition from above\n\n    public function bar($baz, $bat = null)\n    {\n        $params = compact('baz', 'bat');\n        $this->getEventManager()->trigger(__FUNCTION__, $this, $params);\n    }\n}\n\n\n\n\nIn turn, triggering events is only interesting if something is listening for the\nevent.\n\n\nListeners attach to the \nEventManager\n, specifying a named event and the\ncallback to notify. The callback receives an \nEvent\n object, which has accessors\nfor retrieving the event name, target, and parameters. Let's add a listener, and\ntrigger the event.\n\n\nuse Zend\\Log\\Factory as LogFactory;\n\n$log = LogFactory($someConfig);\n$foo = new Foo();\n$foo->getEventManager()->attach('bar', function ($e) use ($log) {\n    $event  = $e->getName();\n    $target = get_class($e->getTarget());\n    $params = json_encode($e->getParams());\n\n    $log->info(sprintf(\n        '%s called on %s, using params %s',\n        $event,\n        $target,\n        $params\n    ));\n});\n\n// The following method call:\n$foo->bar('baz', 'bat');\n\n// Results in the log message reading:\n// bar called on Foo, using params {\"baz\" : \"baz\", \"bat\" : \"bat\"}\"\n\n\n\n\nNote that the second argument to \nattach()\n is any valid PHP callable; an\nanonymous function is shown in the example in order to keep the example\nself-contained.\n\n\nHowever, you could also utilize a valid function name, a functor, a string\nreferencing a static method, or an array callback with a named static method or\ninstance method. Again, any PHP callable is valid.\n\n\nSometimes you may want to specify listeners without yet having an object\ninstance of the class composing an \nEventManager\n. Zend Framework enables this\nthrough the concept of a \nSharedEventManager\n.\n\n\nSimply put, you can inject individual \nEventManager\n instances with a well-known\n\nSharedEventManager\n, and the \nEventManager\n instance will query it for\nadditional listeners.\n\n\nListeners attach to a \nSharedEventManager\n in roughly the same way they do to\nnormal event managers; the call to \nattach\n is identical to the \nEventManager\n,\nbut expects an additional parameter at the beginning: a named instance.\n\n\nRemember the example of composing an \nEventManager\n, how we passed it an array\ncontaining \n__CLASS__\n and \nget_class($this)\n? Those values are then used to\n\nidentify\n the event manager instance, and pull listeners registered with one of\nthose identifiers from the \nSharedEventManager\n.\n\n\nAs an example, assuming we have a \nSharedEventManager\n instance that we know has\nbeen injected in our \nEventManager\n instances (for instance, via dependency\ninjection), we could change the above example to attach via the shared\ncollection:\n\n\nuse Zend\\Log\\Factory as LogFactory;\n\n// Assume $sharedEvents is a Zend\\EventManager\\SharedEventManager instance\n\n$log = LogFactory($someConfig);\n$sharedEvents->attach('Foo', 'bar', function ($e) use ($log) {\n    $event  = $e->getName();\n    $target = get_class($e->getTarget());\n    $params = json_encode($e->getParams());\n\n    $log->info(sprintf(\n        '%s called on %s, using params %s',\n        $event,\n        $target,\n        $params\n    ));\n});\n\n// Later, instantiate Foo:\n$foo = new Foo();\n$foo->setEventManager(new EventManager([], $sharedEvents));\n\n// And we can still trigger the above event:\n$foo->bar('baz', 'bat');\n// results in log message:\n// bar called on Foo, using params {\"baz\" : \"baz\", \"bat\" : \"bat\"}\"\n\n\n\n\nThe \nEventManager\n also provides the ability to detach listeners, short-circuit\nexecution of an event either from within a listener or by testing return values\nof listeners, test and loop through the results returned by listeners,\nprioritize listeners, and more. Many of these features are detailed in the\nexamples.",
            "title": "Quick Start"
        },
        {
            "location": "/quick-start/#quick-start",
            "text": "Typically, you will compose an  EventManager  instance in a class.  use Zend\\EventManager\\EventManagerInterface;\nuse Zend\\EventManager\\EventManager;\nuse Zend\\EventManager\\EventManagerAwareInterface;\n\nclass Foo implements EventManagerAwareInterface\n{\n    protected $events;\n\n    public function setEventManager(EventManagerInterface $events)\n    {\n        $events->setIdentifiers([\n            __CLASS__,\n            get_called_class(),\n        ]);\n        $this->events = $events;\n        return $this;\n    }\n\n    public function getEventManager()\n    {\n        if (null === $this->events) {\n            $this->setEventManager(new EventManager());\n        }\n        return $this->events;\n    }\n}  The above allows users to access the  EventManager  instance, or reset it with a\nnew instance; if one does not exist, it will be lazily instantiated on-demand.  The instance property  $events  is a convention for referring to the\nEventManager instance.  An  EventManager  is really only interesting if it triggers some events.  Basic triggering via the  trigger()  method takes three arguments:   The event  name , which is usually the current function/method name;  The  target , which is usually the current object instance;  Event  arguments , which are usually the arguments provided to the current function/method.   class Foo\n{\n    // ... assume events definition from above\n\n    public function bar($baz, $bat = null)\n    {\n        $params = compact('baz', 'bat');\n        $this->getEventManager()->trigger(__FUNCTION__, $this, $params);\n    }\n}  In turn, triggering events is only interesting if something is listening for the\nevent.  Listeners attach to the  EventManager , specifying a named event and the\ncallback to notify. The callback receives an  Event  object, which has accessors\nfor retrieving the event name, target, and parameters. Let's add a listener, and\ntrigger the event.  use Zend\\Log\\Factory as LogFactory;\n\n$log = LogFactory($someConfig);\n$foo = new Foo();\n$foo->getEventManager()->attach('bar', function ($e) use ($log) {\n    $event  = $e->getName();\n    $target = get_class($e->getTarget());\n    $params = json_encode($e->getParams());\n\n    $log->info(sprintf(\n        '%s called on %s, using params %s',\n        $event,\n        $target,\n        $params\n    ));\n});\n\n// The following method call:\n$foo->bar('baz', 'bat');\n\n// Results in the log message reading:\n// bar called on Foo, using params {\"baz\" : \"baz\", \"bat\" : \"bat\"}\"  Note that the second argument to  attach()  is any valid PHP callable; an\nanonymous function is shown in the example in order to keep the example\nself-contained.  However, you could also utilize a valid function name, a functor, a string\nreferencing a static method, or an array callback with a named static method or\ninstance method. Again, any PHP callable is valid.  Sometimes you may want to specify listeners without yet having an object\ninstance of the class composing an  EventManager . Zend Framework enables this\nthrough the concept of a  SharedEventManager .  Simply put, you can inject individual  EventManager  instances with a well-known SharedEventManager , and the  EventManager  instance will query it for\nadditional listeners.  Listeners attach to a  SharedEventManager  in roughly the same way they do to\nnormal event managers; the call to  attach  is identical to the  EventManager ,\nbut expects an additional parameter at the beginning: a named instance.  Remember the example of composing an  EventManager , how we passed it an array\ncontaining  __CLASS__  and  get_class($this) ? Those values are then used to identify  the event manager instance, and pull listeners registered with one of\nthose identifiers from the  SharedEventManager .  As an example, assuming we have a  SharedEventManager  instance that we know has\nbeen injected in our  EventManager  instances (for instance, via dependency\ninjection), we could change the above example to attach via the shared\ncollection:  use Zend\\Log\\Factory as LogFactory;\n\n// Assume $sharedEvents is a Zend\\EventManager\\SharedEventManager instance\n\n$log = LogFactory($someConfig);\n$sharedEvents->attach('Foo', 'bar', function ($e) use ($log) {\n    $event  = $e->getName();\n    $target = get_class($e->getTarget());\n    $params = json_encode($e->getParams());\n\n    $log->info(sprintf(\n        '%s called on %s, using params %s',\n        $event,\n        $target,\n        $params\n    ));\n});\n\n// Later, instantiate Foo:\n$foo = new Foo();\n$foo->setEventManager(new EventManager([], $sharedEvents));\n\n// And we can still trigger the above event:\n$foo->bar('baz', 'bat');\n// results in log message:\n// bar called on Foo, using params {\"baz\" : \"baz\", \"bat\" : \"bat\"}\"  The  EventManager  also provides the ability to detach listeners, short-circuit\nexecution of an event either from within a listener or by testing return values\nof listeners, test and loop through the results returned by listeners,\nprioritize listeners, and more. Many of these features are detailed in the\nexamples.",
            "title": "Quick Start"
        },
        {
            "location": "/tutorial/",
            "text": "Tutorial\n\n\nThis tutorial explores the various features of zend-eventmanager.\n\n\nTerminology\n\n\n\n\nAn \nEvent\n is a named action.\n\n\nA \nListener\n is any PHP callback that reacts to an \nevent\n.\n\n\nAn \nEventManager\n \naggregates\n listeners for one or more named events, and \ntriggers\n events.\n\n\n\n\nTypically, an \nevent\n will be modeled as an object, containing metadata\nsurrounding when and how it was triggered, including the event name, what object\ntriggered the event (the \"target\"), and what parameters were provided. Events\nare \nnamed\n, which allows a single \nlistener\n to branch logic based on the\nevent.\n\n\nGetting started\n\n\nThe minimal things necessary to start using events are:\n\n\n\n\nAn \nEventManager\n instance\n\n\nOne or more listeners on one or more events\n\n\nA call to \ntrigger()\n an event\n\n\n\n\nThe simplest example looks something like this:\n\n\nuse Zend\\EventManager\\EventManager;\n\n$events = new EventManager();\n$events->attach('do', function ($e) {\n    $event = $e->getName();\n    $params = $e->getParams();\n    printf(\n        'Handled event \"%s\", with parameters %s',\n        $event,\n        json_encode($params)\n    );\n});\n\n$params = )'foo' => 'bar', 'baz' => 'bat'];\n$events->trigger('do', null, $params);\n\n\n\n\nThe above will result in the following:\n\n\nHandled event \"do\", with parameters {\"foo\":\"bar\",\"baz\":\"bat\"}\n\n\n\n\n\n\nNote\n\n\nThroughout this tutorial, we use closures as listeners. However, any valid PHP\ncallback can be attached as a listeners: PHP function names, static class\nmethods, object instance methods, functors, or closures. We use closures\nwithin this post simply for illustration and simplicity.\n\n\n\n\nIf you were paying attention to the example, you will have noted the \nnull\n\nargument. Why is it there?\n\n\nTypically, you will compose an \nEventManager\n within a class, to allow\ntriggering actions within methods. The middle argument to \ntrigger()\n is the\n\"target\", and in the case described, would be the current object instance. This\ngives event listeners access to the calling object, which can often be useful.\n\n\nuse Zend\\EventManager\\EventManager;\nuse Zend\\EventManager\\EventManagerAwareInterface;\nuse Zend\\EventManager\\EventManagerInterface;\n\nclass Example implements EventManagerAwareInterface\n{\n    protected $events;\n\n    public function setEventManager(EventManagerInterface $events)\n    {\n        $events->setIdentifiers([\n            __CLASS__,\n            get_class($this)\n        ]);\n        $this->events = $events;\n    }\n\n    public function getEventManager()\n    {\n        if (! $this->events) {\n            $this->setEventManager(new EventManager());\n        }\n        return $this->events;\n    }\n\n    public function doIt($foo, $baz)\n    {\n        $params = compact('foo', 'baz');\n        $this->getEventManager()->trigger(__FUNCTION__, $this, $params);\n    }\n\n}\n\n$example = new Example();\n\n$example->getEventManager()->attach('doIt', function($e) {\n    $event  = $e->getName();\n    $target = get_class($e->getTarget()); // \"Example\"\n    $params = $e->getParams();\n    printf(\n        'Handled event \"%s\" on target \"%s\", with parameters %s',\n        $event,\n        $target,\n        json_encode($params)\n    );\n});\n\n$example->doIt('bar', 'bat');\n\n\n\n\nThe above is basically the same as the first example. The main difference is\nthat we're now using that middle argument in order to pass the target, the\ninstance of \nExample\n, on to the listeners. Our listener is now retrieving that\n(\n$e->getTarget()\n), and doing something with it.\n\n\nIf you're reading this critically, you should have a new question: What is the\ncall to \nsetIdentifiers()\n for?\n\n\nShared managers\n\n\nOne aspect that the \nEventManager\n implementation provides is an ability to\ncompose a \nSharedEventManagerInterface\n implementation.\n\n\nZend\\EventManager\\SharedEventManagerInterface\n describes an object that\naggregates listeners for events attached to objects with specific \nidentifiers\n.\nIt does not trigger events itself. Instead, an \nEventManager\n instance that\ncomposes a \nSharedEventManager\n will query the \nSharedEventManager\n for\nlisteners on identifiers it's interested in, and trigger those listeners as\nwell.\n\n\nHow does this work, exactly?\n\n\nConsider the following:\n\n\nuse Zend\\EventManager\\SharedEventManager;\n\n$sharedEvents = new SharedEventManager();\n$sharedEvents->attach('Example', 'do', function ($e) {\n    $event  = $e->getName();\n    $target = get_class($e->getTarget()); // \"Example\"\n    $params = $e->getParams();\n    printf(\n        'Handled event \"%s\" on target \"%s\", with parameters %s',\n        $event,\n        $target,\n        json_encode($params)\n    );\n});\n\n\n\n\nThis looks almost identical to the previous example; the key difference is that\nthere is an additional argument at the \nstart\n of the list, \nExample\n. This\ncode is basically saying, \"Listen to the 'do' event of the 'Example' target,\nand, when notified, execute this callback.\"\n\n\nThis is where the \nsetIdentifiers()\n argument of \nEventManager\n comes into play.\nThe method allows passing an array of strings, defining the names of the context\nor targets the given instance will be interested in.\n\n\nSo, getting back to our example, let's assume that the above shared listener is\nregistered, and also that the \nExample\n class is defined as above. We can then\nexecute the following:\n\n\n$example = new Example();\n$example->getEventManager()->setSharedManager($sharedEvents);\n$example->do('bar', 'bat');\n\n\n\n\nand expect the following output:\n\n\nHandled event \"do\" on target \"Example\", with parameters {\"foo\":\"bar\",\"baz\":\"bat\"}\n\n\n\n\nNow, let's say we extended \nExample\n as follows:\n\n\nclass SubExample extends Example\n{\n}\n\n\n\n\nOne interesting aspect of our \nsetEventManager()\n method is that we defined it\nto listen both on \n__CLASS__\n and \nget_class($this)\n. This means that calling\n\ndo()\n on our \nSubExample\n class would also trigger the shared listener! It also\nmeans that, if desired, we could attach to specifically \nSubExample\n, and\nlisteners attached to only the \nExample\n target would not be triggered.\n\n\nFinally, the names used as contexts or targets need not be class names; they can\nbe some name that only has meaning in your application if desired. As an\nexample, you could have a set of classes that respond to \"log\" or \"cache\" \u2014 and\nlisteners on these would be notified by any of them.\n\n\n\n\nNote\n\n\nWe recommend using class names, interface names, and/or abstract class names\nfor identifiers. This makes determining what events are available easier, as\nwell as finding which listeners might be attaching to those events. Interfaces\nmake a particularly good use case, as they allow attaching to a group of\nrelated classes a single operation.\n\n\n\n\nWildcards\n\n\nSo far, with both a normal \nEventManager\n instance and with the\n\nSharedEventManager\n instance, we've seen the usage of singular strings\nrepresenting the event and target names to which we want to attach. What if you\nwant to attach a listener to multiple events or targets?\n\n\nOne answer is to attach to the event manager using the wildcard event, \n*\n.\n\n\nConsider the following examples:\n\n\n$events->attach(\n    '*', // all events\n    $listener\n);\n\n// All targets via wildcard\n$sharedEvents->attach(\n    '*',           // all targets\n    'doSomething', // named event\n    $listener\n);\n\n// Mix and match: all events on a single named target:\n$sharedEvents->attach(\n    'Foo', // target\n    '*',   // all events\n    $listener\n);\n\n// Mix and match: all events on all targets:\n$sharedEvents->attach(\n    '*', // all targets\n    '*', // all events\n    $listener\n);\n\n\n\n\nThe ability to specify wildcard targets and/or events when attaching can slim\ndown your code immensely.\n\n\nListener aggregates\n\n\nAnother approach to listening to multiple events is via a concept of listener\naggregates, represented by \nZend\\EventManager\\ListenerAggregateInterface\n. Via\nthis approach, a single class can listen to multiple events, attaching one or\nmore instance methods as listeners.\n\n\nThis interface defines two methods, \nattach(EventManagerInterface $events)\n and\n\ndetach(EventManagerInterface $events)\n. Basically, you pass an \nEventManager\n\ninstance to one and/or the other, and then it's up to the implementing class to\ndetermine what to do.\n\n\nAs an example:\n\n\nuse Zend\\EventManager\\EventInterface;\nuse Zend\\EventManager\\EventManagerInterface;\nuse Zend\\EventManager\\ListenerAggregateInterface;\nuse Zend\\Log\\Logger;\n\nclass LogEvents implements ListenerAggregateInterface\n{\n    private $listeners = [];\n    private $log;\n\n    public function __construct(Logger $log)\n    {\n        $this->log = $log;\n    }\n\n    public function attach(EventManagerInterface $events)\n    {\n        $this->listeners[] = $events->attach('do', [$this, 'log']);\n        $this->listeners[] = $events->attach('doSomethingElse', [$this, 'log']);\n    }\n\n    public function detach(EventCollection $events)\n    {\n        foreach ($this->listeners as $index => $listener) {\n            $events->detach($listener);\n            unset($this->listeners[$index]);\n        }\n    }\n\n    public function log(EventInterface $e)\n    {\n        $event  = $e->getName();\n        $params = $e->getParams();\n        $this->log->info(sprintf('%s: %s', $event, json_encode($params)));\n    }\n}\n\n\n\n\n\n\nNote\n\n\nThe trait \nZend\\EventManager\\ListenerAggregateTrait\n can be composed to help\nimplement \nListenerAggregateInterface\n; it defines the \n$listeners\n property,\nand the \ndetach()\n logic as demostrated above.\n\n\n\n\nYou can attach this by passing the event manager to the aggregate's \nattach()\n\nmethod:\n\n\n$logListener = new LogEvents($logger);\n$logListener->attach($events);\n\n\n\n\nAny events the aggregate attaches to will then be notified when triggered.\n\n\nWhy bother? For a couple of reasons:\n\n\n\n\nAggregates allow you to have stateful listeners. The above example\n  demonstrates this via the composition of the logger; another example would be\n  tracking configuration options.\n\n\nAggregates allow grouping related listeners in a single class, and attaching\n  them at once.\n\n\n\n\nIntrospecting results\n\n\nSometimes you'll want to know what your listeners returned. One thing to\nremember is that you may have multiple listeners on the same event; the\ninterface for results must be consistent regardless of the number of listeners.\n\n\nThe \nEventManager\n implementation by default returns a\n\nZend\\EventManager\\ResponseCollection\n instance. This class extends PHP's\n\nSplStack\n, allowing you to loop through responses in reverse order (since the\nlast one executed is likely the one you're most interested in). It also\nimplements the following methods:\n\n\n\n\nfirst()\n will retrieve the first result received\n\n\nlast()\n will retrieve the last result received\n\n\ncontains($value)\n allows you to test all values to see if a given one was\n  received, and returns simply a boolean \ntrue\n if found, and \nfalse\n if not.\n\n\n\n\nTypically, you should not worry about the return values from events, as the\nobject triggering the event shouldn't really have much insight into what\nlisteners are attached. However, sometimes you may want to short-circuit\nexecution if interesting results are obtained.\n\n\nShort-circuiting listener execution\n\n\nYou may want to short-ciruit execution if a particular result is obtained, or if\na listener determines that something is wrong, or that it can return something\nquicker than the target.\n\n\nAs examples, one rationale for adding an \nEventManager\n is as a caching\nmechanism. You can trigger one event early in the method, returning if a cache\nis found, and trigger another event late in the method, seeding the cache.\n\n\nThe \nEventManager\n component offers two ways to handle this. The first is to\nuse the methods \ntriggerUntil()\n or \ntriggerEventUntil()\n. These accept a\ncallback as their first argument; if that callback returns a boolean \ntrue\n\nvalue, execution is halted.\n\n\nAs an example:\n\n\npublic function someExpensiveCall($criteria1, $criteria2)\n{\n    $params  = compact('criteria1', 'criteria2');\n    $results = $this->getEventManager()->triggerUntil(\n        function ($r) {\n            return ($r instanceof SomeResultClass);\n        },\n        __FUNCTION__, \n        $this, \n        $params\n    );\n\n    if ($results->stopped()) {\n        return $results->last();\n    }\n\n    // ... do some work ...\n}\n\n\n\n\nWith this paradigm, we know that the likely reason of execution halting is due\nto the last result meeting the test callback criteria; as such, we simply return\nthat last result.\n\n\nThe other way to halt execution is within a listener, acting on the \nEvent\n\nobject it receives. In this case, the listener calls \nstopPropagation(true)\n,\nand the \nEventManager\n will then return without notifying any additional\nlisteners.\n\n\n$events->attach('do', function ($e) {\n    $e->stopPropagation();\n    return new SomeResultClass();\n});\n\n\n\n\nThis, of course, raises some ambiguity when using the trigger paradigm, as you\ncan no longer be certain that the last result meets the criteria it's searching\non. As such, we recommend that you standardize on one approach or the other.\n\n\nKeeping it in order\n\n\nOn occasion, you may be concerned about the order in which listeners execute. As\nan example, you may want to do any logging early, to ensure that if\nshort-circuiting occurs, you've logged; or if implementing a cache, you may want\nto return early if a cache hit is found, and execute late when saving to a\ncache.\n\n\nEach of \nEventManager::attach()\n and \nSharedEventManager::attach()\n accept one\nadditional argument, a \npriority\n. By default, if this is omitted, listeners get\na priority of 1, and are executed in the order in which they are attached.\nHowever, if you provide a priority value, you can influence order of execution.\n\n\n\n\nHigher priority values execute \nearlier\n.\n\n\nLower (negative) priority values execute \nlater\n.\n\n\n\n\nTo borrow an example from earlier:\n\n\n$priority = 100;\n$events->attach('Example', 'do', function($e) {\n    $event  = $e->getName();\n    $target = get_class($e->getTarget()); // \"Example\"\n    $params = $e->getParams();\n    printf(\n        'Handled event \"%s\" on target \"%s\", with parameters %s',\n        $event,\n        $target,\n        json_encode($params)\n    );\n}, $priority);\n\n\n\n\nThis would execute with high priority, meaning it would execute early. If we\nchanged \n$priority\n to \n-100\n, it would execute with low priority, executing\nlate.\n\n\nWhile you can't necessarily know all the listeners attached, chances are you can\nmake adequate guesses when necessary in order to set appropriate priority\nvalues. We advise avoiding setting a priority value unless absolutely necessary.\n\n\nCustom event objects\n\n\nHopefully some of you have been wondering, \"where and when is the \nEvent\n object\ncreated\"? In all of the examples above, it's created based on the arguments\npassed to \ntrigger()\n \u2014 the event name, target, and parameters. Sometimes,\nhowever, you may want greater control over the object.\n\n\nAs an example, one thing that looks like a code smell is when you have code like\nthis:\n\n\n$routeMatch = $e->getParam('route-match', false);\nif ( !$routeMatch) {\n    // Oh noes! we cannot do our work! whatever shall we do?!?!?!\n}\n\n\n\n\nThe problems with this are several. First, relying on string keys is going to\nvery quickly run into problems \u2014 typos when setting or retrieving the argument\ncan lead to hard to debug situations. Second, we now have a documentation issue;\nhow do we document expected arguments? how do we document what we're shoving\ninto the event? Third, as a side effect, we can't use IDE or editor hinting\nsupport \u2014 string keys give these tools nothing to work with.\n\n\nSimilarly, consider how you might represent a computational result of a method\nwhen triggering an event. As an example:\n\n\n// in the method:\n$params['__RESULT'] = $computedResult;\n$events->trigger(__FUNCTION__ . '.post', $this, $params);\n\n// in the listener:\n$result = $e->getParam('__RESULT__');\nif (! $result) {\n    // Oh noes! we cannot do our work! whatever shall we do?!?!?!\n}\n\n\n\n\nSure, that key may be unique, but it suffers from a lot of the same issues.\n\n\nSo, the solution is to create custom events. As an example, we have a custom\n\nMvcEvent\n in zend-mvc. This event composes the application instance,\nthe router, the route match object, request and response objects, the view\nmodel, and also a result. We end up with code like this in our listeners:\n\n\n$response = $e->getResponse();\n$result   = $e->getResult();\nif (is_string($result)) {\n    $content = $view->render('layout.phtml', ['content' => $result]);\n    $response->setContent($content);\n}\n\n\n\n\nBut how do we use this custom event? Simple: the method \ntriggerEvent()\n.\n\n\n$event = new CustomEvent();\n$event->setName('foo');\n$event->setTarget($this);\n$event->setSomeKey($value);\n\n// Injected with event name and target:\n$events->triggerEvent($event);\n\n// Use triggerEventUntil() for criteria-based short-circuiting:\n$results = $events->triggerEventUntil($callback, $event);\n\n\n\n\nThis is a really powerful technique for domain-specific event systems, and\ndefinitely worth experimenting with.\n\n\nPutting it together: Implementing a simple caching system\n\n\nIn previous sections, I indicated that short-circuiting is a way to potentially\nimplement a caching solution. Let's create a full example.\n\n\nFirst, let's define a method that could use caching. You'll note that in most of\nthe examples, I've used \n__FUNCTION__\n as the event name; this is a good\npractice, as it makes it simple to create a macro for triggering events, as well\nas helps to keep event names unique (as they're usually within the context of\nthe triggering class). However, in the case of a caching example, this would\nlead to identical events being triggered. As such, I recommend postfixing the\nevent name with semantic names: \"do.pre\", \"do.post\", \"do.error\", etc. I'll use\nthat convention in this example.\n\n\nAdditionally, you'll notice that the \n$params\n I pass to the event is usually\nthe list of parameters passed to the method. This is because those are often not\nstored in the object, and also to ensure the listeners have the exact same\ncontext as the calling method. But it raises an interesting problem in this\nexample: what name do we give the result of the method? One standard that has\nemerged is the use of \n__RESULT__\n, as double-underscored variables are\ntypically reserved for the sytem.\n\n\nHere's what the method will look like:\n\n\npublic function someExpensiveCall($criteria1, $criteria2)\n{\n    $params  = compact('criteria1', 'criteria2');\n    $results = $this->getEventManager()->triggerUntil(\n        function ($r) {\n            return ($r instanceof SomeResultClass);\n        },\n        __FUNCTION__ . '.pre',\n        $this,\n        $params\n    );\n\n    if ($results->stopped()) {\n        return $results->last();\n    }\n\n    // ... do some work ...\n\n    $params['__RESULT__'] = $calculatedResult;\n    $this->events()->trigger(__FUNCTION__ . '.post', $this, $params);\n    return $calculatedResult;\n}\n\n\n\n\nNow, to provide some caching listeners. We'll need to attach to each of the\n\nsomeExpensiveCall.pre\n and \nsomeExpensiveCall.post\n methods. In the former;\ncase, if a cache hit is detected, we return it, and move on. In the latter, we\nstore the value in the cache.\n\n\nWe'll assume \n$cache\n is defined, and follows the paradigms of \nZend\\Cache\n.\nWe'll want to return early if a hit is detected, and execute late when saving a\ncache (in case the result is modified by another listener). As such, we'll set\nthe \nsomeExpensiveCall.pre\n listener to execute with priority \n100\n, and the\n\nsomeExpensiveCall.post\n listener to execute with priority \n-100\n.\n\n\n$events->attach('someExpensiveCall.pre', function($e) use ($cache) {\n    $params = $e->getParams();\n    $key    = md5(json_encode($params));\n    $hit    = $cache->load($key);\n    return $hit;\n}, 100);\n\n$events->attach('someExpensiveCall.post', function($e) use ($cache) {\n    $params = $e->getParams();\n    $result = $params['__RESULT__'];\n    unset($params['__RESULT__']);\n    $key    = md5(json_encode($params));\n    $cache->save($result, $key);\n}, -100);\n\n\n\n\n\n\nNote\n\n\nThe above could have been done within a \nListenerAggregate\n, which would have\nallowed keeping the \n$cache\n instance as a stateful property, instead of\nimporting it into closures.\n\n\n\n\nAnother approach would be to move the body of the method to a listener as well,\nwhich would allow using the priority system in order to implement caching. That\nwould look like this:\n\n\npublic function setEventManager(EventManagerInterface $events)\n{\n    $this->events = $events;\n    $events->setIdentifiers(array(__CLASS__, get_class($this)));\n    $events->attach('someExpensiveCall', [$this, 'doSomeExpensiveCall']);\n}\n\npublic function someExpensiveCall($criteria1, $criteria2)\n{\n    $params  = compact('criteria1', 'criteria2');\n    $results = $this->getEventManager()->triggerUntil(\n        function ($r) {\n            return ($r instanceof SomeResultClass);\n        },\n        __FUNCTION__,\n        $this,\n        $params\n    );\n    return $results->last();\n}\n\npublic function doSomeExpensiveCall($e)\n{\n    // ... do some work ...\n    $e->setParam('__RESULT__', $calculatedResult);\n    return $calculatedResult;\n}\n\n\n\n\nThe listeners would then attach to the \nsomeExpensiveCall\n event, with the cache\nlookup listener listening at high priority, and the cache storage listener\nlistening at low (negative) priority.\n\n\nSure, we could probably simply add caching to the object itself \u2014 but this\napproach allows the same handlers to be attached to multiple events, or to\nattach multiple listeners to the same events (e.g. an argument validator, a\nlogger and a cache manager). The point is that if you design your object with\nevents in mind, you can easily make it more flexible and extensible, without\nrequiring developers to actually extend it \u2014 they can simply attach listeners.\n\n\nConclusion\n\n\nThe \nEventManager\n is a powerful component. It drives the workflow of zend-mvc,\nand is used in countless components to provide hook points for developers to\nmanipulate the workflow. It can be put to any number of uses inside your own\ncode, and is an important part of your Zend Framework toolbox.",
            "title": "Tutorial"
        },
        {
            "location": "/tutorial/#tutorial",
            "text": "This tutorial explores the various features of zend-eventmanager.",
            "title": "Tutorial"
        },
        {
            "location": "/tutorial/#terminology",
            "text": "An  Event  is a named action.  A  Listener  is any PHP callback that reacts to an  event .  An  EventManager   aggregates  listeners for one or more named events, and  triggers  events.   Typically, an  event  will be modeled as an object, containing metadata\nsurrounding when and how it was triggered, including the event name, what object\ntriggered the event (the \"target\"), and what parameters were provided. Events\nare  named , which allows a single  listener  to branch logic based on the\nevent.",
            "title": "Terminology"
        },
        {
            "location": "/tutorial/#getting-started",
            "text": "The minimal things necessary to start using events are:   An  EventManager  instance  One or more listeners on one or more events  A call to  trigger()  an event   The simplest example looks something like this:  use Zend\\EventManager\\EventManager;\n\n$events = new EventManager();\n$events->attach('do', function ($e) {\n    $event = $e->getName();\n    $params = $e->getParams();\n    printf(\n        'Handled event \"%s\", with parameters %s',\n        $event,\n        json_encode($params)\n    );\n});\n\n$params = )'foo' => 'bar', 'baz' => 'bat'];\n$events->trigger('do', null, $params);  The above will result in the following:  Handled event \"do\", with parameters {\"foo\":\"bar\",\"baz\":\"bat\"}",
            "title": "Getting started"
        },
        {
            "location": "/tutorial/#note",
            "text": "Throughout this tutorial, we use closures as listeners. However, any valid PHP\ncallback can be attached as a listeners: PHP function names, static class\nmethods, object instance methods, functors, or closures. We use closures\nwithin this post simply for illustration and simplicity.   If you were paying attention to the example, you will have noted the  null \nargument. Why is it there?  Typically, you will compose an  EventManager  within a class, to allow\ntriggering actions within methods. The middle argument to  trigger()  is the\n\"target\", and in the case described, would be the current object instance. This\ngives event listeners access to the calling object, which can often be useful.  use Zend\\EventManager\\EventManager;\nuse Zend\\EventManager\\EventManagerAwareInterface;\nuse Zend\\EventManager\\EventManagerInterface;\n\nclass Example implements EventManagerAwareInterface\n{\n    protected $events;\n\n    public function setEventManager(EventManagerInterface $events)\n    {\n        $events->setIdentifiers([\n            __CLASS__,\n            get_class($this)\n        ]);\n        $this->events = $events;\n    }\n\n    public function getEventManager()\n    {\n        if (! $this->events) {\n            $this->setEventManager(new EventManager());\n        }\n        return $this->events;\n    }\n\n    public function doIt($foo, $baz)\n    {\n        $params = compact('foo', 'baz');\n        $this->getEventManager()->trigger(__FUNCTION__, $this, $params);\n    }\n\n}\n\n$example = new Example();\n\n$example->getEventManager()->attach('doIt', function($e) {\n    $event  = $e->getName();\n    $target = get_class($e->getTarget()); // \"Example\"\n    $params = $e->getParams();\n    printf(\n        'Handled event \"%s\" on target \"%s\", with parameters %s',\n        $event,\n        $target,\n        json_encode($params)\n    );\n});\n\n$example->doIt('bar', 'bat');  The above is basically the same as the first example. The main difference is\nthat we're now using that middle argument in order to pass the target, the\ninstance of  Example , on to the listeners. Our listener is now retrieving that\n( $e->getTarget() ), and doing something with it.  If you're reading this critically, you should have a new question: What is the\ncall to  setIdentifiers()  for?",
            "title": "Note"
        },
        {
            "location": "/tutorial/#shared-managers",
            "text": "One aspect that the  EventManager  implementation provides is an ability to\ncompose a  SharedEventManagerInterface  implementation.  Zend\\EventManager\\SharedEventManagerInterface  describes an object that\naggregates listeners for events attached to objects with specific  identifiers .\nIt does not trigger events itself. Instead, an  EventManager  instance that\ncomposes a  SharedEventManager  will query the  SharedEventManager  for\nlisteners on identifiers it's interested in, and trigger those listeners as\nwell.  How does this work, exactly?  Consider the following:  use Zend\\EventManager\\SharedEventManager;\n\n$sharedEvents = new SharedEventManager();\n$sharedEvents->attach('Example', 'do', function ($e) {\n    $event  = $e->getName();\n    $target = get_class($e->getTarget()); // \"Example\"\n    $params = $e->getParams();\n    printf(\n        'Handled event \"%s\" on target \"%s\", with parameters %s',\n        $event,\n        $target,\n        json_encode($params)\n    );\n});  This looks almost identical to the previous example; the key difference is that\nthere is an additional argument at the  start  of the list,  Example . This\ncode is basically saying, \"Listen to the 'do' event of the 'Example' target,\nand, when notified, execute this callback.\"  This is where the  setIdentifiers()  argument of  EventManager  comes into play.\nThe method allows passing an array of strings, defining the names of the context\nor targets the given instance will be interested in.  So, getting back to our example, let's assume that the above shared listener is\nregistered, and also that the  Example  class is defined as above. We can then\nexecute the following:  $example = new Example();\n$example->getEventManager()->setSharedManager($sharedEvents);\n$example->do('bar', 'bat');  and expect the following output:  Handled event \"do\" on target \"Example\", with parameters {\"foo\":\"bar\",\"baz\":\"bat\"}  Now, let's say we extended  Example  as follows:  class SubExample extends Example\n{\n}  One interesting aspect of our  setEventManager()  method is that we defined it\nto listen both on  __CLASS__  and  get_class($this) . This means that calling do()  on our  SubExample  class would also trigger the shared listener! It also\nmeans that, if desired, we could attach to specifically  SubExample , and\nlisteners attached to only the  Example  target would not be triggered.  Finally, the names used as contexts or targets need not be class names; they can\nbe some name that only has meaning in your application if desired. As an\nexample, you could have a set of classes that respond to \"log\" or \"cache\" \u2014 and\nlisteners on these would be notified by any of them.",
            "title": "Shared managers"
        },
        {
            "location": "/tutorial/#note_1",
            "text": "We recommend using class names, interface names, and/or abstract class names\nfor identifiers. This makes determining what events are available easier, as\nwell as finding which listeners might be attaching to those events. Interfaces\nmake a particularly good use case, as they allow attaching to a group of\nrelated classes a single operation.",
            "title": "Note"
        },
        {
            "location": "/tutorial/#wildcards",
            "text": "So far, with both a normal  EventManager  instance and with the SharedEventManager  instance, we've seen the usage of singular strings\nrepresenting the event and target names to which we want to attach. What if you\nwant to attach a listener to multiple events or targets?  One answer is to attach to the event manager using the wildcard event,  * .  Consider the following examples:  $events->attach(\n    '*', // all events\n    $listener\n);\n\n// All targets via wildcard\n$sharedEvents->attach(\n    '*',           // all targets\n    'doSomething', // named event\n    $listener\n);\n\n// Mix and match: all events on a single named target:\n$sharedEvents->attach(\n    'Foo', // target\n    '*',   // all events\n    $listener\n);\n\n// Mix and match: all events on all targets:\n$sharedEvents->attach(\n    '*', // all targets\n    '*', // all events\n    $listener\n);  The ability to specify wildcard targets and/or events when attaching can slim\ndown your code immensely.",
            "title": "Wildcards"
        },
        {
            "location": "/tutorial/#listener-aggregates",
            "text": "Another approach to listening to multiple events is via a concept of listener\naggregates, represented by  Zend\\EventManager\\ListenerAggregateInterface . Via\nthis approach, a single class can listen to multiple events, attaching one or\nmore instance methods as listeners.  This interface defines two methods,  attach(EventManagerInterface $events)  and detach(EventManagerInterface $events) . Basically, you pass an  EventManager \ninstance to one and/or the other, and then it's up to the implementing class to\ndetermine what to do.  As an example:  use Zend\\EventManager\\EventInterface;\nuse Zend\\EventManager\\EventManagerInterface;\nuse Zend\\EventManager\\ListenerAggregateInterface;\nuse Zend\\Log\\Logger;\n\nclass LogEvents implements ListenerAggregateInterface\n{\n    private $listeners = [];\n    private $log;\n\n    public function __construct(Logger $log)\n    {\n        $this->log = $log;\n    }\n\n    public function attach(EventManagerInterface $events)\n    {\n        $this->listeners[] = $events->attach('do', [$this, 'log']);\n        $this->listeners[] = $events->attach('doSomethingElse', [$this, 'log']);\n    }\n\n    public function detach(EventCollection $events)\n    {\n        foreach ($this->listeners as $index => $listener) {\n            $events->detach($listener);\n            unset($this->listeners[$index]);\n        }\n    }\n\n    public function log(EventInterface $e)\n    {\n        $event  = $e->getName();\n        $params = $e->getParams();\n        $this->log->info(sprintf('%s: %s', $event, json_encode($params)));\n    }\n}",
            "title": "Listener aggregates"
        },
        {
            "location": "/tutorial/#note_2",
            "text": "The trait  Zend\\EventManager\\ListenerAggregateTrait  can be composed to help\nimplement  ListenerAggregateInterface ; it defines the  $listeners  property,\nand the  detach()  logic as demostrated above.   You can attach this by passing the event manager to the aggregate's  attach() \nmethod:  $logListener = new LogEvents($logger);\n$logListener->attach($events);  Any events the aggregate attaches to will then be notified when triggered.  Why bother? For a couple of reasons:   Aggregates allow you to have stateful listeners. The above example\n  demonstrates this via the composition of the logger; another example would be\n  tracking configuration options.  Aggregates allow grouping related listeners in a single class, and attaching\n  them at once.",
            "title": "Note"
        },
        {
            "location": "/tutorial/#introspecting-results",
            "text": "Sometimes you'll want to know what your listeners returned. One thing to\nremember is that you may have multiple listeners on the same event; the\ninterface for results must be consistent regardless of the number of listeners.  The  EventManager  implementation by default returns a Zend\\EventManager\\ResponseCollection  instance. This class extends PHP's SplStack , allowing you to loop through responses in reverse order (since the\nlast one executed is likely the one you're most interested in). It also\nimplements the following methods:   first()  will retrieve the first result received  last()  will retrieve the last result received  contains($value)  allows you to test all values to see if a given one was\n  received, and returns simply a boolean  true  if found, and  false  if not.   Typically, you should not worry about the return values from events, as the\nobject triggering the event shouldn't really have much insight into what\nlisteners are attached. However, sometimes you may want to short-circuit\nexecution if interesting results are obtained.",
            "title": "Introspecting results"
        },
        {
            "location": "/tutorial/#short-circuiting-listener-execution",
            "text": "You may want to short-ciruit execution if a particular result is obtained, or if\na listener determines that something is wrong, or that it can return something\nquicker than the target.  As examples, one rationale for adding an  EventManager  is as a caching\nmechanism. You can trigger one event early in the method, returning if a cache\nis found, and trigger another event late in the method, seeding the cache.  The  EventManager  component offers two ways to handle this. The first is to\nuse the methods  triggerUntil()  or  triggerEventUntil() . These accept a\ncallback as their first argument; if that callback returns a boolean  true \nvalue, execution is halted.  As an example:  public function someExpensiveCall($criteria1, $criteria2)\n{\n    $params  = compact('criteria1', 'criteria2');\n    $results = $this->getEventManager()->triggerUntil(\n        function ($r) {\n            return ($r instanceof SomeResultClass);\n        },\n        __FUNCTION__, \n        $this, \n        $params\n    );\n\n    if ($results->stopped()) {\n        return $results->last();\n    }\n\n    // ... do some work ...\n}  With this paradigm, we know that the likely reason of execution halting is due\nto the last result meeting the test callback criteria; as such, we simply return\nthat last result.  The other way to halt execution is within a listener, acting on the  Event \nobject it receives. In this case, the listener calls  stopPropagation(true) ,\nand the  EventManager  will then return without notifying any additional\nlisteners.  $events->attach('do', function ($e) {\n    $e->stopPropagation();\n    return new SomeResultClass();\n});  This, of course, raises some ambiguity when using the trigger paradigm, as you\ncan no longer be certain that the last result meets the criteria it's searching\non. As such, we recommend that you standardize on one approach or the other.",
            "title": "Short-circuiting listener execution"
        },
        {
            "location": "/tutorial/#keeping-it-in-order",
            "text": "On occasion, you may be concerned about the order in which listeners execute. As\nan example, you may want to do any logging early, to ensure that if\nshort-circuiting occurs, you've logged; or if implementing a cache, you may want\nto return early if a cache hit is found, and execute late when saving to a\ncache.  Each of  EventManager::attach()  and  SharedEventManager::attach()  accept one\nadditional argument, a  priority . By default, if this is omitted, listeners get\na priority of 1, and are executed in the order in which they are attached.\nHowever, if you provide a priority value, you can influence order of execution.   Higher priority values execute  earlier .  Lower (negative) priority values execute  later .   To borrow an example from earlier:  $priority = 100;\n$events->attach('Example', 'do', function($e) {\n    $event  = $e->getName();\n    $target = get_class($e->getTarget()); // \"Example\"\n    $params = $e->getParams();\n    printf(\n        'Handled event \"%s\" on target \"%s\", with parameters %s',\n        $event,\n        $target,\n        json_encode($params)\n    );\n}, $priority);  This would execute with high priority, meaning it would execute early. If we\nchanged  $priority  to  -100 , it would execute with low priority, executing\nlate.  While you can't necessarily know all the listeners attached, chances are you can\nmake adequate guesses when necessary in order to set appropriate priority\nvalues. We advise avoiding setting a priority value unless absolutely necessary.",
            "title": "Keeping it in order"
        },
        {
            "location": "/tutorial/#custom-event-objects",
            "text": "Hopefully some of you have been wondering, \"where and when is the  Event  object\ncreated\"? In all of the examples above, it's created based on the arguments\npassed to  trigger()  \u2014 the event name, target, and parameters. Sometimes,\nhowever, you may want greater control over the object.  As an example, one thing that looks like a code smell is when you have code like\nthis:  $routeMatch = $e->getParam('route-match', false);\nif ( !$routeMatch) {\n    // Oh noes! we cannot do our work! whatever shall we do?!?!?!\n}  The problems with this are several. First, relying on string keys is going to\nvery quickly run into problems \u2014 typos when setting or retrieving the argument\ncan lead to hard to debug situations. Second, we now have a documentation issue;\nhow do we document expected arguments? how do we document what we're shoving\ninto the event? Third, as a side effect, we can't use IDE or editor hinting\nsupport \u2014 string keys give these tools nothing to work with.  Similarly, consider how you might represent a computational result of a method\nwhen triggering an event. As an example:  // in the method:\n$params['__RESULT'] = $computedResult;\n$events->trigger(__FUNCTION__ . '.post', $this, $params);\n\n// in the listener:\n$result = $e->getParam('__RESULT__');\nif (! $result) {\n    // Oh noes! we cannot do our work! whatever shall we do?!?!?!\n}  Sure, that key may be unique, but it suffers from a lot of the same issues.  So, the solution is to create custom events. As an example, we have a custom MvcEvent  in zend-mvc. This event composes the application instance,\nthe router, the route match object, request and response objects, the view\nmodel, and also a result. We end up with code like this in our listeners:  $response = $e->getResponse();\n$result   = $e->getResult();\nif (is_string($result)) {\n    $content = $view->render('layout.phtml', ['content' => $result]);\n    $response->setContent($content);\n}  But how do we use this custom event? Simple: the method  triggerEvent() .  $event = new CustomEvent();\n$event->setName('foo');\n$event->setTarget($this);\n$event->setSomeKey($value);\n\n// Injected with event name and target:\n$events->triggerEvent($event);\n\n// Use triggerEventUntil() for criteria-based short-circuiting:\n$results = $events->triggerEventUntil($callback, $event);  This is a really powerful technique for domain-specific event systems, and\ndefinitely worth experimenting with.",
            "title": "Custom event objects"
        },
        {
            "location": "/tutorial/#putting-it-together-implementing-a-simple-caching-system",
            "text": "In previous sections, I indicated that short-circuiting is a way to potentially\nimplement a caching solution. Let's create a full example.  First, let's define a method that could use caching. You'll note that in most of\nthe examples, I've used  __FUNCTION__  as the event name; this is a good\npractice, as it makes it simple to create a macro for triggering events, as well\nas helps to keep event names unique (as they're usually within the context of\nthe triggering class). However, in the case of a caching example, this would\nlead to identical events being triggered. As such, I recommend postfixing the\nevent name with semantic names: \"do.pre\", \"do.post\", \"do.error\", etc. I'll use\nthat convention in this example.  Additionally, you'll notice that the  $params  I pass to the event is usually\nthe list of parameters passed to the method. This is because those are often not\nstored in the object, and also to ensure the listeners have the exact same\ncontext as the calling method. But it raises an interesting problem in this\nexample: what name do we give the result of the method? One standard that has\nemerged is the use of  __RESULT__ , as double-underscored variables are\ntypically reserved for the sytem.  Here's what the method will look like:  public function someExpensiveCall($criteria1, $criteria2)\n{\n    $params  = compact('criteria1', 'criteria2');\n    $results = $this->getEventManager()->triggerUntil(\n        function ($r) {\n            return ($r instanceof SomeResultClass);\n        },\n        __FUNCTION__ . '.pre',\n        $this,\n        $params\n    );\n\n    if ($results->stopped()) {\n        return $results->last();\n    }\n\n    // ... do some work ...\n\n    $params['__RESULT__'] = $calculatedResult;\n    $this->events()->trigger(__FUNCTION__ . '.post', $this, $params);\n    return $calculatedResult;\n}  Now, to provide some caching listeners. We'll need to attach to each of the someExpensiveCall.pre  and  someExpensiveCall.post  methods. In the former;\ncase, if a cache hit is detected, we return it, and move on. In the latter, we\nstore the value in the cache.  We'll assume  $cache  is defined, and follows the paradigms of  Zend\\Cache .\nWe'll want to return early if a hit is detected, and execute late when saving a\ncache (in case the result is modified by another listener). As such, we'll set\nthe  someExpensiveCall.pre  listener to execute with priority  100 , and the someExpensiveCall.post  listener to execute with priority  -100 .  $events->attach('someExpensiveCall.pre', function($e) use ($cache) {\n    $params = $e->getParams();\n    $key    = md5(json_encode($params));\n    $hit    = $cache->load($key);\n    return $hit;\n}, 100);\n\n$events->attach('someExpensiveCall.post', function($e) use ($cache) {\n    $params = $e->getParams();\n    $result = $params['__RESULT__'];\n    unset($params['__RESULT__']);\n    $key    = md5(json_encode($params));\n    $cache->save($result, $key);\n}, -100);",
            "title": "Putting it together: Implementing a simple caching system"
        },
        {
            "location": "/tutorial/#note_3",
            "text": "The above could have been done within a  ListenerAggregate , which would have\nallowed keeping the  $cache  instance as a stateful property, instead of\nimporting it into closures.   Another approach would be to move the body of the method to a listener as well,\nwhich would allow using the priority system in order to implement caching. That\nwould look like this:  public function setEventManager(EventManagerInterface $events)\n{\n    $this->events = $events;\n    $events->setIdentifiers(array(__CLASS__, get_class($this)));\n    $events->attach('someExpensiveCall', [$this, 'doSomeExpensiveCall']);\n}\n\npublic function someExpensiveCall($criteria1, $criteria2)\n{\n    $params  = compact('criteria1', 'criteria2');\n    $results = $this->getEventManager()->triggerUntil(\n        function ($r) {\n            return ($r instanceof SomeResultClass);\n        },\n        __FUNCTION__,\n        $this,\n        $params\n    );\n    return $results->last();\n}\n\npublic function doSomeExpensiveCall($e)\n{\n    // ... do some work ...\n    $e->setParam('__RESULT__', $calculatedResult);\n    return $calculatedResult;\n}  The listeners would then attach to the  someExpensiveCall  event, with the cache\nlookup listener listening at high priority, and the cache storage listener\nlistening at low (negative) priority.  Sure, we could probably simply add caching to the object itself \u2014 but this\napproach allows the same handlers to be attached to multiple events, or to\nattach multiple listeners to the same events (e.g. an argument validator, a\nlogger and a cache manager). The point is that if you design your object with\nevents in mind, you can easily make it more flexible and extensible, without\nrequiring developers to actually extend it \u2014 they can simply attach listeners.",
            "title": "Note"
        },
        {
            "location": "/tutorial/#conclusion",
            "text": "The  EventManager  is a powerful component. It drives the workflow of zend-mvc,\nand is used in countless components to provide hook points for developers to\nmanipulate the workflow. It can be put to any number of uses inside your own\ncode, and is an important part of your Zend Framework toolbox.",
            "title": "Conclusion"
        },
        {
            "location": "/examples/",
            "text": "Examples\n\n\nModifying Arguments\n\n\nOccasionally it can be useful to allow listeners to modify the arguments they\nreceive so that later listeners or the calling method will receive those changed\nvalues.\n\n\nAs an example, you might want to pre-filter a date that you know will arrive as\na string and convert it to a \nDateTime\n argument.\n\n\nTo do this, you can pass your arguments to \nprepareArgs()\n, and pass this new\nobject when triggering an event. You will then pull that value back into your\nmethod.\n\n\nuse DateTime;\n\nclass ValueObject\n{\n    // assume a composed event manager\n\n    function inject(array $values)\n    {\n        $argv = compact('values');\n        $argv = $this->getEventManager()->prepareArgs($argv);\n        $this->getEventManager()->trigger(__FUNCTION__, $this, $argv);\n        $date = isset($argv['values']['date'])\n            ? $argv['values']['date']\n            : new DateTime('now');\n\n        // ...\n    }\n}\n\n$v = new ValueObject();\n\n$v->getEventManager()->attach('inject', function($e) {\n    $values = $e->getParam('values');\n    if (! $values) {\n        return;\n    }\n\n    $values['date'] = isset($values['date'])\n        ? new DateTime($values['date'])\n        : new DateTime('now');\n\n    $e->setParam('values', $values);\n});\n\n$v->inject([\n    'date' => '2011-08-10 15:30:29',\n]);\n\n\n\n\nShort Circuiting\n\n\nOne common use case for events is to trigger listeners until either one\nindicates no further processing should be done, or until a return value meets\nspecific criteria.\n\n\nAs an example, a request listener might be able to return a response object, and\nwould signal to the target to stop event propagation.\n\n\n$listener = function($e) {\n    // do some work\n\n    // Stop propagation and return a response\n    $e->stopPropagation(true);\n    return $response;\n};\n\n\n\n\nAlternately, the request handler could halt execution at the first listener that\nreturns a response.\n\n\nclass Foo implements DispatchableInterface\n{\n    // assume composed event manager\n\n    public function dispatch(Request $request, Response $response = null)\n    {\n        $argv = compact('request', 'response');\n        $results = $this->getEventManager()->triggerUntil(function($v) {\n            return ($v instanceof Response);\n        }, __FUNCTION__, $this, $argv);\n    }\n}\n\n\n\n\nTypically, you may want to return the value that stopped execution, or use it\nsome way. All \ntrigger*()\n methods return a \nResponseCollection\n instance; call\nits \nstopped()\n method to test if execution was stopped, and the \nlast()\n method\nto retrieve the return value from the last executed listener:\n\n\nclass Foo implements DispatchableInterface\n{\n    // assume composed event manager\n\n    public function dispatch(Request $request, Response $response = null)\n    {\n        $argv = compact('request', 'response');\n        $results = $this->getEventManager()->triggerUntil(function($v) {\n            return ($v instanceof Response);\n        }, __FUNCTION__, $this, $argv);\n\n        // Test if execution was halted, and return last result:\n        if ($results->stopped()) {\n            return $results->last();\n        }\n\n        // continue...\n    }\n}\n\n\n\n\nAssigning Priority to Listeners\n\n\nOne use case for the \nEventManager\n is for implementing caching systems. As\nsuch, you often want to check the cache early, and save to it late.\n\n\nThe third argument to \nattach()\n is a priority value. The higher this number,\nthe earlier that listener will execute; the lower it is, the later it executes.\nThe value defaults to 1, and values will trigger in the order registered within\na given priority.\n\n\nTo implement a caching system, our method will need to trigger an event at\nmethod start as well as at method end. At method start, we want an event that\nwill trigger early; at method end, an event should trigger late.\n\n\nHere is the class in which we want caching:\n\n\nclass SomeValueObject\n{\n    // assume it composes an event manager\n\n    public function get($id)\n    {\n        $params = compact('id');\n        $results = $this->getEventManager()->trigger('get.pre', $this, $params);\n\n        // If an event stopped propagation, return the value\n        if ($results->stopped()) {\n            return $results->last();\n        }\n\n        // do some work...\n\n        $params['__RESULT__'] = $someComputedContent;\n        $this->getEventManager()->trigger('get.post', $this, $params);\n    }\n}\n\n\n\n\nNow, let's create a \nListenerAggregateInterface\n implementation that can handle\ncaching for us:\n\n\nuse Zend\\Cache\\Cache;\nuse Zend\\EventManager\\EventManagerInterface;\nuse Zend\\EventManager\\ListenerAggregateInterface;\nuse Zend\\EventManager\\ListenerAggregateTrait;\nuse Zend\\EventManager\\EventInterface;\n\nclass CacheListener implements ListenerAggregateInterface\n{\n    use ListenerAggregateTrait;\n\n    private $cache;\n\n    public function __construct(Cache $cache)\n    {\n        $this->cache = $cache;\n    }\n\n    public function attach(EventManagerInterface $events)\n    {\n        $this->listeners[] = $events->attach('get.pre', [$this, 'load'], 100);\n        $this->listeners[] = $events->attach('get.post', [$this, 'save'], -100);\n    }\n\n    public function load(EventInterface $e)\n    {\n        $id = get_class($e->getTarget()) . '-' . json_encode($e->getParams());\n        if (false !== ($content = $this->cache->load($id))) {\n            $e->stopPropagation(true);\n            return $content;\n        }\n    }\n\n    public function save(EventInterface $e)\n    {\n        $params  = $e->getParams();\n        $content = $params['__RESULT__'];\n        unset($params['__RESULT__']);\n\n        $id = get_class($e->getTarget()) . '-' . json_encode($params);\n        $this->cache->save($content, $id);\n    }\n}\n\n\n\n\nWe can then attach the aggregate to an event manager instance.\n\n\n$value         = new SomeValueObject();\n$cacheListener = new CacheListener($cache);\n$cacheListener->attach($value->getEventManager());\n\n\n\n\nNow, as we call \nget()\n, if we have a cached entry, it will be returned\nimmediately; if not, a computed entry will be cached when we complete the\nmethod.",
            "title": "Examples"
        },
        {
            "location": "/examples/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/examples/#modifying-arguments",
            "text": "Occasionally it can be useful to allow listeners to modify the arguments they\nreceive so that later listeners or the calling method will receive those changed\nvalues.  As an example, you might want to pre-filter a date that you know will arrive as\na string and convert it to a  DateTime  argument.  To do this, you can pass your arguments to  prepareArgs() , and pass this new\nobject when triggering an event. You will then pull that value back into your\nmethod.  use DateTime;\n\nclass ValueObject\n{\n    // assume a composed event manager\n\n    function inject(array $values)\n    {\n        $argv = compact('values');\n        $argv = $this->getEventManager()->prepareArgs($argv);\n        $this->getEventManager()->trigger(__FUNCTION__, $this, $argv);\n        $date = isset($argv['values']['date'])\n            ? $argv['values']['date']\n            : new DateTime('now');\n\n        // ...\n    }\n}\n\n$v = new ValueObject();\n\n$v->getEventManager()->attach('inject', function($e) {\n    $values = $e->getParam('values');\n    if (! $values) {\n        return;\n    }\n\n    $values['date'] = isset($values['date'])\n        ? new DateTime($values['date'])\n        : new DateTime('now');\n\n    $e->setParam('values', $values);\n});\n\n$v->inject([\n    'date' => '2011-08-10 15:30:29',\n]);",
            "title": "Modifying Arguments"
        },
        {
            "location": "/examples/#short-circuiting",
            "text": "One common use case for events is to trigger listeners until either one\nindicates no further processing should be done, or until a return value meets\nspecific criteria.  As an example, a request listener might be able to return a response object, and\nwould signal to the target to stop event propagation.  $listener = function($e) {\n    // do some work\n\n    // Stop propagation and return a response\n    $e->stopPropagation(true);\n    return $response;\n};  Alternately, the request handler could halt execution at the first listener that\nreturns a response.  class Foo implements DispatchableInterface\n{\n    // assume composed event manager\n\n    public function dispatch(Request $request, Response $response = null)\n    {\n        $argv = compact('request', 'response');\n        $results = $this->getEventManager()->triggerUntil(function($v) {\n            return ($v instanceof Response);\n        }, __FUNCTION__, $this, $argv);\n    }\n}  Typically, you may want to return the value that stopped execution, or use it\nsome way. All  trigger*()  methods return a  ResponseCollection  instance; call\nits  stopped()  method to test if execution was stopped, and the  last()  method\nto retrieve the return value from the last executed listener:  class Foo implements DispatchableInterface\n{\n    // assume composed event manager\n\n    public function dispatch(Request $request, Response $response = null)\n    {\n        $argv = compact('request', 'response');\n        $results = $this->getEventManager()->triggerUntil(function($v) {\n            return ($v instanceof Response);\n        }, __FUNCTION__, $this, $argv);\n\n        // Test if execution was halted, and return last result:\n        if ($results->stopped()) {\n            return $results->last();\n        }\n\n        // continue...\n    }\n}",
            "title": "Short Circuiting"
        },
        {
            "location": "/examples/#assigning-priority-to-listeners",
            "text": "One use case for the  EventManager  is for implementing caching systems. As\nsuch, you often want to check the cache early, and save to it late.  The third argument to  attach()  is a priority value. The higher this number,\nthe earlier that listener will execute; the lower it is, the later it executes.\nThe value defaults to 1, and values will trigger in the order registered within\na given priority.  To implement a caching system, our method will need to trigger an event at\nmethod start as well as at method end. At method start, we want an event that\nwill trigger early; at method end, an event should trigger late.  Here is the class in which we want caching:  class SomeValueObject\n{\n    // assume it composes an event manager\n\n    public function get($id)\n    {\n        $params = compact('id');\n        $results = $this->getEventManager()->trigger('get.pre', $this, $params);\n\n        // If an event stopped propagation, return the value\n        if ($results->stopped()) {\n            return $results->last();\n        }\n\n        // do some work...\n\n        $params['__RESULT__'] = $someComputedContent;\n        $this->getEventManager()->trigger('get.post', $this, $params);\n    }\n}  Now, let's create a  ListenerAggregateInterface  implementation that can handle\ncaching for us:  use Zend\\Cache\\Cache;\nuse Zend\\EventManager\\EventManagerInterface;\nuse Zend\\EventManager\\ListenerAggregateInterface;\nuse Zend\\EventManager\\ListenerAggregateTrait;\nuse Zend\\EventManager\\EventInterface;\n\nclass CacheListener implements ListenerAggregateInterface\n{\n    use ListenerAggregateTrait;\n\n    private $cache;\n\n    public function __construct(Cache $cache)\n    {\n        $this->cache = $cache;\n    }\n\n    public function attach(EventManagerInterface $events)\n    {\n        $this->listeners[] = $events->attach('get.pre', [$this, 'load'], 100);\n        $this->listeners[] = $events->attach('get.post', [$this, 'save'], -100);\n    }\n\n    public function load(EventInterface $e)\n    {\n        $id = get_class($e->getTarget()) . '-' . json_encode($e->getParams());\n        if (false !== ($content = $this->cache->load($id))) {\n            $e->stopPropagation(true);\n            return $content;\n        }\n    }\n\n    public function save(EventInterface $e)\n    {\n        $params  = $e->getParams();\n        $content = $params['__RESULT__'];\n        unset($params['__RESULT__']);\n\n        $id = get_class($e->getTarget()) . '-' . json_encode($params);\n        $this->cache->save($content, $id);\n    }\n}  We can then attach the aggregate to an event manager instance.  $value         = new SomeValueObject();\n$cacheListener = new CacheListener($cache);\n$cacheListener->attach($value->getEventManager());  Now, as we call  get() , if we have a cached entry, it will be returned\nimmediately; if not, a computed entry will be cached when we complete the\nmethod.",
            "title": "Assigning Priority to Listeners"
        },
        {
            "location": "/wildcard-listeners/",
            "text": "Wildcard Listeners\n\n\nSometimes you'll want to attach the same listener to all events of a given\ninstance \u2014 or potentially, with a shared event collection, all contexts.\n\n\nAttaching using the wildcard\n\n\nTo attach to all events on a given \nEventManager\n instance, you can use the\nwildcard event, \n*\n:\n\n\n$events = new EventManager();\n$events->attach('*', $listener);\n\n\n\n\nNote that if you specify a priority, that priority will be used for this\nlistener for any event triggered.\n\n\nWhat the above specifies is that \nany\n event triggered by the event manager\ninstance will result in notification of this particular listener.\n\n\nAttaching using the wildcard via a SharedEventManager\n\n\nUsing the \nSharedEventManager\n, you can indicate that you want to attach to all\nevents of a given identifier, a single named event across all identifiers, or\nall events on all identifiers.\n\n\n$sharedEvents = new SharedEventManager();\n\n// Attach to all events on the context \"foo\"\n$sharedEvents->attach('foo', '*', $listener);\n\n// Attach to the \"foo\" event of any context:\n$sharedEvents->attach('*', 'foo', $listener);\n\n// Attach to all events on all contexts:\n$sharedEvents->attach('*', '*', $listener);\n\n\n\n\nNote that if you specify a priority, that priority will be used for all events\nspecified.",
            "title": "Wildcard Listeners"
        },
        {
            "location": "/wildcard-listeners/#wildcard-listeners",
            "text": "Sometimes you'll want to attach the same listener to all events of a given\ninstance \u2014 or potentially, with a shared event collection, all contexts.",
            "title": "Wildcard Listeners"
        },
        {
            "location": "/wildcard-listeners/#attaching-using-the-wildcard",
            "text": "To attach to all events on a given  EventManager  instance, you can use the\nwildcard event,  * :  $events = new EventManager();\n$events->attach('*', $listener);  Note that if you specify a priority, that priority will be used for this\nlistener for any event triggered.  What the above specifies is that  any  event triggered by the event manager\ninstance will result in notification of this particular listener.",
            "title": "Attaching using the wildcard"
        },
        {
            "location": "/wildcard-listeners/#attaching-using-the-wildcard-via-a-sharedeventmanager",
            "text": "Using the  SharedEventManager , you can indicate that you want to attach to all\nevents of a given identifier, a single named event across all identifiers, or\nall events on all identifiers.  $sharedEvents = new SharedEventManager();\n\n// Attach to all events on the context \"foo\"\n$sharedEvents->attach('foo', '*', $listener);\n\n// Attach to the \"foo\" event of any context:\n$sharedEvents->attach('*', 'foo', $listener);\n\n// Attach to all events on all contexts:\n$sharedEvents->attach('*', '*', $listener);  Note that if you specify a priority, that priority will be used for all events\nspecified.",
            "title": "Attaching using the wildcard via a SharedEventManager"
        },
        {
            "location": "/aggregates/",
            "text": "Listener Aggregates\n\n\nListener aggregates\n exist to facilitate two operations:\n\n\n\n\nAttaching many listeners at once.\n\n\nAttaching stateful listeners.\n\n\n\n\nA listener aggregate is a class implementing\n\nZend\\EventManager\\ListenerAggregateInterface\n, which defines two methods:\n\n\nattach(EventManagerInterface $events, $priority = 1);\ndetach(EventManagerInterface $events);\n\n\n\n\nTo attach an aggregate to an event manager, you pass the event manager to the\naggregate's \nattach()\n method; in that method, you will then attach listeners to\nthe events you are interested in.\n\n\nImplementation\n\n\nTo implement \nListenerAggregateInterface\n, you need to define the \nattach()\n and\n\ndetach()\n methods. A typical implementation will look something like this:\n\n\nuse Zend\\EventManager\\EventInterface;\nuse Zend\\EventManager\\EventManagerInterface;\nuse Zend\\EventManager\\ListenerAggregateInterface;\n\nclass Aggregate implements ListenerAggregateInterface\n{\n    private $listeners = [];\n\n    public function attach(EventManagerInterface $events, $priority = 1)\n    {\n        $this->listeners[] = $events->attach('something', [$this, 'onSomething'], $priority);\n        $this->listeners[] = $events->attach('else', [$this, 'onElse'], $priority);\n        $this->listeners[] = $events->attach('again', [$this, 'onAgain'], $priority);\n    }\n\n    public function detach(EventManagerInterface $events)\n    {\n        foreach ($this->listeners as $index => $listener) {\n            $events->detach($listener);\n            unset($this->listeners[$index]);\n        }\n    }\n\n    public function onSomething(EventInterface $event)\n    {\n        // handle event\n    }\n\n    public function onElse(EventInterface $event)\n    {\n        // handle event\n    }\n\n    public function onAgain(EventInterface $event)\n    {\n        // handle event\n    }\n}\n\n\n\n\nBecause the logic for detaching is essentially the same in all implementations,\nwe provide two facilities for implementing this:\n\n\n\n\nZend\\EventManager\\AbstractListenerAggregate\n is an abstract class that\n  defines the \n$listeners\n property and the \ndetach()\n method. You may \nextend\n\n  it in order to create an implementation.\n\n\nZend\\EventManager\\ListenerAggregateTrait\n is a trait that defines the\n  \n$listeners\n property and the \ndetach()\n method. You may \nimplement\n\n  \nZend\\EventManager\\ListenerAggregateInterface\n and \nuse\n this trait to\n  implement the \ndetach()\n logic.\n\n\n\n\nUsage\n\n\nTo use an aggregate listener, you need to attach it to the event manager. As\nnoted in the intro to this section, you do so by passing the event\nmanager to the aggregate's \nattach()\n method:\n\n\n// Assume $events is an EventManager instance, and $aggregate is an instance of\n// the Aggregate class defined earlier.\n$aggregate->attach($events);\n\n\n\n\nRecommendations\n\n\n\n\n\n\nWe recommend using listener aggregates when you have several listeners that are\n  related and/or share common dependencies and/or business logic. This helps keep\n  the logic in the same location, and helps reduce dependencies.\n\n\n\n\n\n\nWe recommend using the verbiage \non<Event Name>\n  to name your listener\n  methods. This helps hint that they will be triggered \non an event\n, and\n  semantically ties them to the specific event name.",
            "title": "Listener Aggregates"
        },
        {
            "location": "/aggregates/#listener-aggregates",
            "text": "Listener aggregates  exist to facilitate two operations:   Attaching many listeners at once.  Attaching stateful listeners.   A listener aggregate is a class implementing Zend\\EventManager\\ListenerAggregateInterface , which defines two methods:  attach(EventManagerInterface $events, $priority = 1);\ndetach(EventManagerInterface $events);  To attach an aggregate to an event manager, you pass the event manager to the\naggregate's  attach()  method; in that method, you will then attach listeners to\nthe events you are interested in.",
            "title": "Listener Aggregates"
        },
        {
            "location": "/aggregates/#implementation",
            "text": "To implement  ListenerAggregateInterface , you need to define the  attach()  and detach()  methods. A typical implementation will look something like this:  use Zend\\EventManager\\EventInterface;\nuse Zend\\EventManager\\EventManagerInterface;\nuse Zend\\EventManager\\ListenerAggregateInterface;\n\nclass Aggregate implements ListenerAggregateInterface\n{\n    private $listeners = [];\n\n    public function attach(EventManagerInterface $events, $priority = 1)\n    {\n        $this->listeners[] = $events->attach('something', [$this, 'onSomething'], $priority);\n        $this->listeners[] = $events->attach('else', [$this, 'onElse'], $priority);\n        $this->listeners[] = $events->attach('again', [$this, 'onAgain'], $priority);\n    }\n\n    public function detach(EventManagerInterface $events)\n    {\n        foreach ($this->listeners as $index => $listener) {\n            $events->detach($listener);\n            unset($this->listeners[$index]);\n        }\n    }\n\n    public function onSomething(EventInterface $event)\n    {\n        // handle event\n    }\n\n    public function onElse(EventInterface $event)\n    {\n        // handle event\n    }\n\n    public function onAgain(EventInterface $event)\n    {\n        // handle event\n    }\n}  Because the logic for detaching is essentially the same in all implementations,\nwe provide two facilities for implementing this:   Zend\\EventManager\\AbstractListenerAggregate  is an abstract class that\n  defines the  $listeners  property and the  detach()  method. You may  extend \n  it in order to create an implementation.  Zend\\EventManager\\ListenerAggregateTrait  is a trait that defines the\n   $listeners  property and the  detach()  method. You may  implement \n   Zend\\EventManager\\ListenerAggregateInterface  and  use  this trait to\n  implement the  detach()  logic.",
            "title": "Implementation"
        },
        {
            "location": "/aggregates/#usage",
            "text": "To use an aggregate listener, you need to attach it to the event manager. As\nnoted in the intro to this section, you do so by passing the event\nmanager to the aggregate's  attach()  method:  // Assume $events is an EventManager instance, and $aggregate is an instance of\n// the Aggregate class defined earlier.\n$aggregate->attach($events);",
            "title": "Usage"
        },
        {
            "location": "/aggregates/#recommendations",
            "text": "We recommend using listener aggregates when you have several listeners that are\n  related and/or share common dependencies and/or business logic. This helps keep\n  the logic in the same location, and helps reduce dependencies.    We recommend using the verbiage  on<Event Name>   to name your listener\n  methods. This helps hint that they will be triggered  on an event , and\n  semantically ties them to the specific event name.",
            "title": "Recommendations"
        },
        {
            "location": "/lazy-listeners/intro/",
            "text": "Lazy Listeners\n\n\nLazy listeners are a new feature in version 3.0, provided to reduce the\nperformance overhead of fetching listeners and/or aggregates from a Dependency\nInjection Container until they are actually triggered.\n\n\nThe feature consists of three classes:\n\n\n\n\nZend\\EventManager\\LazyListener\n, which provides basic capabilities for\n  wrapping the retrieval of a listener from a container and invoking it.\n\n\nZend\\EventManager\\LazyEventListener\n, which extends \nLazyListener\n but adds\n  awareness of the event and optionally priority to use when attaching the\n  listener. These are primarily used and created by:\n\n\nZend\\EventManager\\LazyListenerAggregate\n, which can take a list of\n  \nLazyEventListeners\n and/or their definitions, and be used as an aggregate\n  listener for attaching the lazy listeners to an event manager.\n\n\n\n\nPreparation\n\n\nIn order to use the lazy listeners feature, you will need to install\ncontainer-interop, if you haven't already:\n\n\n$ composer require container-interop/container-interop",
            "title": "Intro"
        },
        {
            "location": "/lazy-listeners/intro/#lazy-listeners",
            "text": "Lazy listeners are a new feature in version 3.0, provided to reduce the\nperformance overhead of fetching listeners and/or aggregates from a Dependency\nInjection Container until they are actually triggered.  The feature consists of three classes:   Zend\\EventManager\\LazyListener , which provides basic capabilities for\n  wrapping the retrieval of a listener from a container and invoking it.  Zend\\EventManager\\LazyEventListener , which extends  LazyListener  but adds\n  awareness of the event and optionally priority to use when attaching the\n  listener. These are primarily used and created by:  Zend\\EventManager\\LazyListenerAggregate , which can take a list of\n   LazyEventListeners  and/or their definitions, and be used as an aggregate\n  listener for attaching the lazy listeners to an event manager.",
            "title": "Lazy Listeners"
        },
        {
            "location": "/lazy-listeners/intro/#preparation",
            "text": "In order to use the lazy listeners feature, you will need to install\ncontainer-interop, if you haven't already:  $ composer require container-interop/container-interop",
            "title": "Preparation"
        },
        {
            "location": "/lazy-listeners/lazy-listener/",
            "text": "LazyListener\n\n\nZend\\EventManager\\LazyListener\n provides a callable wrapper around fetching a\nlistener from a container and invoking it.\n\n\nUsage\n\n\nTo create a \nLazyListener\n instance, you must pass to its constructor:\n\n\n\n\na \ndefinition\n of the listener; this is an array defining:\n\n\na \nlistener\n key, with the name of the listener service to pull from the container.\n\n\na \nmethod\n key, with the name of the method to invoke on the listener instance.\n\n\n\n\n\n\na \ncontainer\n; this is a \ncontainer-interop\n,\n  such as provided by\n  \nzend-servicemanager\n,\n  [Aura.Di](https://github.com/auraphp/Aura.Di], etc.\n\n\noptionally an \n$env\n array; this is a set of options or other configuration to\n  use when creating the listener instance. Since not all containers support\n  passing additional options at creation, we recommend omitting the \n$env\n\n  argument when creating portable applications.\n\n\n\n\nAs an example, let's assume:\n\n\n\n\nWe have a listener registered in our container with the service name\n  \nMy\\Application\\Listener\n.\n\n\nThe specific listener method is \nonDispatch\n.\n\n\nI have a container-interop instance in the variable \n$container\n and an event\n  manager in the variable \n$events\n.\n\n\n\n\nI might then create and attach my lazy listener as follows:\n\n\nuse My\\Application\\Listener;\nuse Zend\\EventManager\\LazyListener;\n\n$events->attach('foo', new LazyListener([\n    'listener' => Listener::class,\n    'method'   => 'onDispatch',\n], $container));\n\n\n\n\nLazyListener\n implements the method \n__invoke()\n, allowing you to attach it\ndirectly as a callable listener!\n\n\nInternally, it will do essentially the following:\n\n\n$listener = $container->get($this->listener);\n$method   = $this->method;\nreturn $listener->{$method}($event);",
            "title": "LazyListener"
        },
        {
            "location": "/lazy-listeners/lazy-listener/#lazylistener",
            "text": "Zend\\EventManager\\LazyListener  provides a callable wrapper around fetching a\nlistener from a container and invoking it.",
            "title": "LazyListener"
        },
        {
            "location": "/lazy-listeners/lazy-listener/#usage",
            "text": "To create a  LazyListener  instance, you must pass to its constructor:   a  definition  of the listener; this is an array defining:  a  listener  key, with the name of the listener service to pull from the container.  a  method  key, with the name of the method to invoke on the listener instance.    a  container ; this is a  container-interop ,\n  such as provided by\n   zend-servicemanager ,\n  [Aura.Di](https://github.com/auraphp/Aura.Di], etc.  optionally an  $env  array; this is a set of options or other configuration to\n  use when creating the listener instance. Since not all containers support\n  passing additional options at creation, we recommend omitting the  $env \n  argument when creating portable applications.   As an example, let's assume:   We have a listener registered in our container with the service name\n   My\\Application\\Listener .  The specific listener method is  onDispatch .  I have a container-interop instance in the variable  $container  and an event\n  manager in the variable  $events .   I might then create and attach my lazy listener as follows:  use My\\Application\\Listener;\nuse Zend\\EventManager\\LazyListener;\n\n$events->attach('foo', new LazyListener([\n    'listener' => Listener::class,\n    'method'   => 'onDispatch',\n], $container));  LazyListener  implements the method  __invoke() , allowing you to attach it\ndirectly as a callable listener!  Internally, it will do essentially the following:  $listener = $container->get($this->listener);\n$method   = $this->method;\nreturn $listener->{$method}($event);",
            "title": "Usage"
        },
        {
            "location": "/lazy-listeners/lazy-event-listener/",
            "text": "LazyEventListener\n\n\nZend\\EventManager\\LazyEventListener\n extends from\n\nLazyListener\n, but \nrequires\n supplying the event name to\nwhich to attach, and optionally the priority, in the definition supplied at\nconstruction. This allows it to be a standalone instance that a listener\naggregate can then query and use to attach to an event manager instance.\n\n\nUsage\n\n\nAs noted in the introduction, the \nLazyEventListener\n is aware of two additional\nkeys in the definition supplied at instantiation:\n\n\n\n\nevent\n is the name of the event to which the lazy listener should attach.\n\n\npriority\n can optionally be provided to indicate the priority at which the\n  lazy listener should attach.\n\n\n\n\nAs an example, let's assume:\n\n\n\n\nWe have a listener registered in our container with the service name\n  \nMy\\Application\\Listener\n, and\n\n\nwe want to use the method \nonDispatch\n when listening; further,\n\n\nwe want to attach it to the event \ndispatch\n,\n\n\nat priority 100.\n\n\n\n\nAdditionally, we'll assume that we have a container-interop instance in the\nvariable \n$container\n and an event manager in the variable \n$events\n.\n\n\nYou could create the lazy event listener as follows:\n\n\nuse My\\Application\\Listener;\nuse Zend\\EventManager\\LazyEventListener;\n\n$listener = new LazyEventListener([\n    'listener' => Listener::class,\n    'method'   => 'onDispatch',\n    'event'    => 'dispatch',\n    'priority' => 100,\n], $container);\n\n\n\n\nMethods\n\n\nLazyEventListener\n exposes two methods:\n\n\n\n\ngetEvent()\n returns the event name used.\n\n\ngetPriority($default = 1)\n returns either the priority passed at\n  instantiation, or, if none was provided, the default passed when invoking the\n  method.\n\n\n\n\nAggregates\n\n\nThe \nLazyEventListener\n features are primarily geared towards registering lazy\nlisteners in aggregates. To that end, you will rarely instantiate or interact\nwith them directly; instead, you'll leave that to the\n\nLazyListenerAggregate\n.",
            "title": "LazyEventListener"
        },
        {
            "location": "/lazy-listeners/lazy-event-listener/#lazyeventlistener",
            "text": "Zend\\EventManager\\LazyEventListener  extends from LazyListener , but  requires  supplying the event name to\nwhich to attach, and optionally the priority, in the definition supplied at\nconstruction. This allows it to be a standalone instance that a listener\naggregate can then query and use to attach to an event manager instance.",
            "title": "LazyEventListener"
        },
        {
            "location": "/lazy-listeners/lazy-event-listener/#usage",
            "text": "As noted in the introduction, the  LazyEventListener  is aware of two additional\nkeys in the definition supplied at instantiation:   event  is the name of the event to which the lazy listener should attach.  priority  can optionally be provided to indicate the priority at which the\n  lazy listener should attach.   As an example, let's assume:   We have a listener registered in our container with the service name\n   My\\Application\\Listener , and  we want to use the method  onDispatch  when listening; further,  we want to attach it to the event  dispatch ,  at priority 100.   Additionally, we'll assume that we have a container-interop instance in the\nvariable  $container  and an event manager in the variable  $events .  You could create the lazy event listener as follows:  use My\\Application\\Listener;\nuse Zend\\EventManager\\LazyEventListener;\n\n$listener = new LazyEventListener([\n    'listener' => Listener::class,\n    'method'   => 'onDispatch',\n    'event'    => 'dispatch',\n    'priority' => 100,\n], $container);",
            "title": "Usage"
        },
        {
            "location": "/lazy-listeners/lazy-event-listener/#methods",
            "text": "LazyEventListener  exposes two methods:   getEvent()  returns the event name used.  getPriority($default = 1)  returns either the priority passed at\n  instantiation, or, if none was provided, the default passed when invoking the\n  method.",
            "title": "Methods"
        },
        {
            "location": "/lazy-listeners/lazy-event-listener/#aggregates",
            "text": "The  LazyEventListener  features are primarily geared towards registering lazy\nlisteners in aggregates. To that end, you will rarely instantiate or interact\nwith them directly; instead, you'll leave that to the LazyListenerAggregate .",
            "title": "Aggregates"
        },
        {
            "location": "/lazy-listeners/lazy-listener-aggregate/",
            "text": "LazyListenerAggregate\n\n\nZend\\EventManager\\LazyListenerAggregate\n exists to facilitate attaching a\nnumber of listeners as lazy listeners.\n\n\nUsage\n\n\nSimilar to a \nLazyListener\n or\n\nLazyEventListener\n, the \nLazyListenerAggregate\n accepts\na definition (or, rather, set of definitions) a container-interop instance, and\noptionall an \n$env\n array to its constructor.\n\n\nUnlike either, however, the definition provided is an array of definitions to\nuse to create \nLazyEventListener\n instances; you may also intersperse actual\n\nLazyEventListener\n instances if desired.\n\n\nAs an example, let's assume we have two listeners,\n\nMy\\Application\\RouteListener\n and \nMy\\Application\\DispatchListener\n; the first\nwill use its \nonRoute()\n method to listen to the \nroute\n event at priority 100,\nthe second its \nonDispatch()\n method to listen to the \ndispatch\n event at\npriority -100.\n\n\nuse My\\Application\\DispatchListener;\nuse My\\Application\\RouteListener;\nuse Zend\\EventManager\\LazyListenerAggregate;\n\n$definitions = [\n    [\n        'listener' => RouteListener::class,\n        'method'   => 'onRoute',\n        'event'    => 'route',\n        'priority' => 100,\n    ],\n    [\n        'listener' => DispatchListener::class,\n        'method'   => 'onDispatch',\n        'event'    => 'dispatch',\n        'priority' => -100,\n    ],\n];\n\n$aggregate = new LazyListenerAggregate(\n    $definitions,\n    $container\n);\n$aggregate->attach($events);\n\n\n\n\nInternally, the \nLazyListenerAggregate\n will create \nLazyEventListener\n\ninstances, and during its \nattach()\n phase use them to attach to the event\nmanager using the event and priority they compose.\n\n\nBelow is a functionally identical example, mixing in a concrete\n\nLazyEventListener\n instance for one listener:\n\n\nuse My\\Application\\DispatchListener;\nuse My\\Application\\RouteListener;\nuse Zend\\EventManager\\LazyEventListener;\nuse Zend\\EventManager\\LazyListenerAggregate;\n\n$dispatchListener = new LazyEventListener([\n    'listener' => DispatchListener::class,\n    'method'   => 'onDispatch',\n    'event'    => 'dispatch',\n    'priority' => -100,\n], $container);\n\n$definitions = [\n    [\n        'listener' => RouteListener::class,\n        'method'   => 'onRoute',\n        'event'    => 'route',\n        'priority' => 100,\n    ],\n    $dispatchListener,\n];\n\n$aggregate = new LazyListenerAggregate(\n    $definitions,\n    $container\n);\n$aggregate->attach($events);\n\n\n\n\nRecommendations\n\n\nWe recommend using \nLazyListenerAggregate\n when you have listeners you will be\npulling from a Dependency Injection Container, but which may not execute on\nevery request; this will help minimize the number of objects pulled from the\nDIC. As pulling instances from a DIC is often an expensive operation, this can\nbe a healthy performance optimization.",
            "title": "LazyListenerAggregate"
        },
        {
            "location": "/lazy-listeners/lazy-listener-aggregate/#lazylisteneraggregate",
            "text": "Zend\\EventManager\\LazyListenerAggregate  exists to facilitate attaching a\nnumber of listeners as lazy listeners.",
            "title": "LazyListenerAggregate"
        },
        {
            "location": "/lazy-listeners/lazy-listener-aggregate/#usage",
            "text": "Similar to a  LazyListener  or LazyEventListener , the  LazyListenerAggregate  accepts\na definition (or, rather, set of definitions) a container-interop instance, and\noptionall an  $env  array to its constructor.  Unlike either, however, the definition provided is an array of definitions to\nuse to create  LazyEventListener  instances; you may also intersperse actual LazyEventListener  instances if desired.  As an example, let's assume we have two listeners, My\\Application\\RouteListener  and  My\\Application\\DispatchListener ; the first\nwill use its  onRoute()  method to listen to the  route  event at priority 100,\nthe second its  onDispatch()  method to listen to the  dispatch  event at\npriority -100.  use My\\Application\\DispatchListener;\nuse My\\Application\\RouteListener;\nuse Zend\\EventManager\\LazyListenerAggregate;\n\n$definitions = [\n    [\n        'listener' => RouteListener::class,\n        'method'   => 'onRoute',\n        'event'    => 'route',\n        'priority' => 100,\n    ],\n    [\n        'listener' => DispatchListener::class,\n        'method'   => 'onDispatch',\n        'event'    => 'dispatch',\n        'priority' => -100,\n    ],\n];\n\n$aggregate = new LazyListenerAggregate(\n    $definitions,\n    $container\n);\n$aggregate->attach($events);  Internally, the  LazyListenerAggregate  will create  LazyEventListener \ninstances, and during its  attach()  phase use them to attach to the event\nmanager using the event and priority they compose.  Below is a functionally identical example, mixing in a concrete LazyEventListener  instance for one listener:  use My\\Application\\DispatchListener;\nuse My\\Application\\RouteListener;\nuse Zend\\EventManager\\LazyEventListener;\nuse Zend\\EventManager\\LazyListenerAggregate;\n\n$dispatchListener = new LazyEventListener([\n    'listener' => DispatchListener::class,\n    'method'   => 'onDispatch',\n    'event'    => 'dispatch',\n    'priority' => -100,\n], $container);\n\n$definitions = [\n    [\n        'listener' => RouteListener::class,\n        'method'   => 'onRoute',\n        'event'    => 'route',\n        'priority' => 100,\n    ],\n    $dispatchListener,\n];\n\n$aggregate = new LazyListenerAggregate(\n    $definitions,\n    $container\n);\n$aggregate->attach($events);",
            "title": "Usage"
        },
        {
            "location": "/lazy-listeners/lazy-listener-aggregate/#recommendations",
            "text": "We recommend using  LazyListenerAggregate  when you have listeners you will be\npulling from a Dependency Injection Container, but which may not execute on\nevery request; this will help minimize the number of objects pulled from the\nDIC. As pulling instances from a DIC is often an expensive operation, this can\nbe a healthy performance optimization.",
            "title": "Recommendations"
        },
        {
            "location": "/api/",
            "text": "EventManager API\n\n\nThis section details the public API of the \nEventManager\n, \nSharedEventManager\n,\n\nEventInterface\n, and \nResponseCollection\n.\n\n\nEventManager\n\n\nConstructor\n\n\npublic function __construct(\n    SharedEventManagerInterface $sharedEvents = null,\n    array $identifiers = []\n)\n\n\n\n\nThe \nEventManager\n instance accepts a shared event manager instance and\nidentifiers to use with the shared event manager.\n\n\nsetEventPrototype()\n\n\npublic function setEventPrototype(EventInterface $event) : void\n\n\n\n\nUse this method in order to provide an event prototype. The event prototype is\nused with the \ntrigger()\n and \ntriggerUntil()\n methods to create a new event\ninstance; the prototype is cloned and populated with the event name, target, and\narguments passed to the method.\n\n\ngetSharedManager()\n\n\npublic function getSharedManager() : null|SharedEventManagerInterface\n\n\n\n\nUse this method to retrieve the composed shared event manager instance, if any.\n\n\ngetIdentifiers()\n\n\npublic function getIdentifiers() : array\n\n\n\n\nUse this method to retrieve the current list of identifiers the event manager\ndefines. Identifiers are used when retrieving listeners from the composed shared\nevent manager.\n\n\nsetIdentifiers() and addIdentifiers()\n\n\npublic function setIdentifiers(array $identifiers) : void\npublic function addIdentifiers(array $identifiers) : void\n\n\n\n\nUse these methods to manipulate the list of identifiers the event manager\nis interested in. \nsetIdentifiers()\n will overwrite any identifiers previously\nset, while \naddIdentifiers()\n will merge them.\n\n\ntrigger()\n\n\ntrigger($eventName, $target = null, $argv = []) : ResponseCollection\n\n\n\n\nwhere:\n\n\n\n\n$eventName\n is a string event name.\n\n\n$target\n is the target of the event; usually the object composing the event\n  manager instance.\n\n\n$argv\n is an array or \nArrayAccess\n instance of arguments that provide\n  context for the event. Typically these will be the arguments passed to the\n  function in which the trigger call occurs.\n\n\n\n\nThe target and/or arguments may be omitted, but the event name is required.\n\n\nWhen done triggering, the method returns a \nResponseCollection\n.\n\n\ntriggerUntil()\n\n\ntriggerUntil(callable $callback, $eventName, $target = null, $argv = []) : ResponseCollection\n\n\n\n\ntriggerUntil()\n is a sibling to \ntrigger()\n, and prefixes the argument list\nwith a single \n$callback\n.\n\n\nThe \n$callback\n is invoked after each listener completes, with the result of\nthat listener. The \n$callback\n should inspect the result, and determine if it\nshould result in short-circuiting the event loop. Returning a boolean \ntrue\n\nvalue indicates that the criteria has been met and the event loop should end.\n\n\nAs an example:\n\n\n$events->attach('foo', function ($e) {\n    echo \"Triggered first\\n\";\n    return true;\n});\n$events->attach('foo', function ($e) {\n    echo \"Triggered second\\n\";\n    return false;\n});\n$events->attach('foo', function ($e) {\n    echo \"Triggered third\\n\";\n    return true;\n});\n\n$events->triggerUntil(function ($result) {\n    return (false === $result);\n}, 'foo');\n\n\n\n\nIn the above example, the event loop will short-circuit after the second\nlistener executes, resulting in the following output:\n\n\nTriggered first\nTriggered second\n\n\n\n\ntriggerEvent()\n\n\ntriggerEvent(EventInterfce $event) : ResponseCollection\n\n\n\n\nThis method is a sibling to \ntrigger()\n, but unlike \ntrigger()\n, it accepts an\n\nEventInterface\n instance as its sole argument. It is up to the caller to ensure\nthe event is properly populated.\n\n\nThis method behaves identically to \ntrigger()\n, returning a \nResponseCollection\n\nafter all listeners have been triggered.\n\n\ntriggerEventUntil()\n\n\ntriggerEventUntil(callable $callback, EventInterface $event) : ResponseCollection\n\n\n\n\nThis method is a sibling to \ntriggerEvent()\n and \ntriggerUntil()\n. Like\n\ntriggerUntil()\n, the first argument is a PHP callable to invoke for each\nresponse, and is used to determine whether or not to short-circuit execution.\nLike \ntriggerEvent()\n, the next argument is an \nEventInterface\n instance.\n\n\nattach()\n\n\nattach($eventName, callable $listener, $priority = 1) : callable\n\n\n\n\nUse \nattach()\n to attach a callable listener to a named event. \n$priority\n can\nbe used to indicate where in the listener queue the event should be executed.\nPriorities \nmust\n be integers. High positive integers indicate higher priority\n(will execute first), while low, negative integers indicate lower priority (will\nexecute last). The default priority is 1, and listeners registered with the same\npriority will execute in the order in which they attach to the event manager.\n\n\nThe method returns the listener attached.\n\n\ndetach()\n\n\ndetach(callable $listener, $eventName = null) : void\n\n\n\n\nUse \ndetach()\n to remove a listener. When a named \n$eventName\n is provided, the\nmethod will detach the listener from that event only (or, if the event does not\nexist in the event manager, nothing will occur). If no event is provided, or the\nwildcard event is provided, the listener will be detached from all events.\n\n\nclearListeners()\n\n\nclearListeners($eventName) : void\n\n\n\n\nUse this method to remove all listeners for a given named event.\n\n\nprepareArgs()\n\n\nprepareArgs(array $args) : ArrayObject\n\n\n\n\nNormally when working with an event, if you want to change any arguments in the\nevent, you would need to do the following:\n\n\n$args = $e->getParams();\n\n// Manipulate args:\n$args['foo'] = 'bar';\n\n// Pass them back in:\n$e->setParams($args);\n\n\n\n\nIf the arguments you provide are an \nobject\n, however, you can manipulate them\ndirectly:\n\n\n$args = $e->getParams();\n\n// Manipulate args:\n$args->foo = 'bar';\n\n// Done!\n\n\n\n\nUsing an object, however, makes accessing individual parameters difficult:\n\n\n$foo = $e->getParam('foo'); // How should the event know how to get this?\n\n\n\n\nAs such, we recommend passing either an array or an \nArrayObject\n instance for\nevent arguments. If you pass the latter, you get the benefit of being able to\nmainpulate by reference.\n\n\nprepareArgs()\n can thus be used to return an \nArrayObject\n representation of\nyour aguments to pass to \ntrigger()\n or \ntriggerUntil()\n:\n\n\n$events->attach('foo', $this, $events->prepareArgs(compact('bar', 'baz')));\n\n\n\n\nSharedEventManager\n\n\nattach()\n\n\nattach($identifier, $eventName, callable $listener, $priority = 1) : void\n\n\n\n\nAttach a listener to a named event triggered by an identified context, where:\n\n\n\n\n$identifier\n is a string identifier that may be defined by an \nEventManager\n\n  instance; \n$identifier\n may be the wildcard \n*\n.\n\n\n$eventName\n is a string event name (or the wildcard \n*\n).\n\n\n$listener\n is a PHP callable that will listen for an event.\n\n\n$priority\n is the priority to use when attaching the listener.\n\n\n\n\ndetach()\n\n\ndetach(callable $listener, $identifer = null, $eventName = null) : void\n\n\n\n\nDetach a listener, optionally from a single identifier, and optionally from a\nnamed event, where:\n\n\n\n\n$listener\n is the PHP callable listener to detach.\n\n\n$identifier\n is a string identifier from which to detach.\n\n\n$eventName\n is a string event name from which to detach.\n\n\n\n\nIf no or a null \n$identifier\n is provided, the listener will be detached from all\nidentified contexts. If no or a null \n$eventName\n is provided, the listener will be\ndetached from all named events discovered.\n\n\ngetListeners()\n\n\ngetListeners(array $identifiers, $eventName = null) : array[]\n\n\n\n\nRetrieves all registered listeners for a given identifier and named event; if\nthe event name is omitted, it returns all listeners for the identifier.\n\n\nEach value in the array returned is in the form:\n\n\n[\n    'listener' => callable,\n    'priority' => int,\n]\n\n\n\n\nImplementations should return wildcard listeners in this array.\n\n\nThis method is used by the \nEventManager\n in order to get a set of listeners for\nthe event being triggered.\n\n\nclearListeners()\n\n\nclearListeners($id, $eventName = null) : bool\n\n\n\n\nThis event will clear all listeners for a given identifier, or, if specified,\nthe specific event for the named identifier.\n\n\nEventInterface\n\n\nIn most cases, you will use \nZend\\EventManager\\Event\n, but some components will\ndefine custom events. The \nEventInterface\n thus defines the common methods\nacross any event implementation.\n\n\ngetName()\n\n\ngetName() : string\n\n\n\n\nReturns the event name.\n\n\ngetTarget()\n\n\ngetTarget() : null|string|object\n\n\n\n\nReturns the event target, if any.\n\n\ngetParams()\n\n\ngetParams() : array|ArrayAccess\n\n\n\n\nReturns the event parameters, if any.\n\n\ngetParam()\n\n\ngetParam($name, $default = null) : mixed\n\n\n\n\nReturns a single named parameter, returning the \n$default\n if not found.\n\n\nsetName()\n\n\nsetName($name) : void\n\n\n\n\nSets the event name.\n\n\nsetTarget()\n\n\nsetTarget($target) : void\n\n\n\n\nSets the event target. \n$target\n may be a string or object.\n\n\nsetParams()\n\n\nsetParams($parms) : void\n\n\n\n\nSet the event parameters; \n$params\n should be an array or object implementing\n\nArrayAccess\n.\n\n\nsetParam()\n\n\nsetParam($name, $value) : void\n\n\n\n\nSet a single named event parameter value.\n\n\nstopPropagation()\n\n\nstopPropagation($flag = true) : void\n\n\n\n\nIndicate whether or not event propagation should halt (short-circuit). This\nvalue is what will be returned by \npropagationIsStopped()\n.\n\n\npropagationIsStopped()\n\n\npropagationIsStopped() : bool\n\n\n\n\nUsed by the event manager to determine if the event has indicated that the event\nloop should short-circuit.\n\n\nResponseCollection\n\n\nA \nResponseCollection\n instance is returned by each of \ntrigger()\n,\n\ntriggerUntil()\n, \ntriggerEvent()\n, and \ntriggerEventUntil()\n, and represents\nthe various results of listener execution.\n\n\nThe \nResponseCollection\n is iterable, and iteration will return the various\nresponses in the order in which they were provided. In addition, it has the API\nlisted below.\n\n\nstopped()\n\n\nstopped() : bool\n\n\n\n\nUse this to determine if something caused the event loop to short-circuit.\n\n\nfirst()\n\n\nfirst() : mixed\n\n\n\n\nReturns the result from the first listener executed.\n\n\nlast()\n\n\nlast() : mixed\n\n\n\n\nReturns the result from the last listener executed.\n\n\ncontains()\n\n\ncontains($value) : bool\n\n\n\n\nQuery the response collection to determine if a specific value was returned by\nany listener.",
            "title": "EventManager API"
        },
        {
            "location": "/api/#eventmanager-api",
            "text": "This section details the public API of the  EventManager ,  SharedEventManager , EventInterface , and  ResponseCollection .",
            "title": "EventManager API"
        },
        {
            "location": "/api/#eventmanager",
            "text": "",
            "title": "EventManager"
        },
        {
            "location": "/api/#constructor",
            "text": "public function __construct(\n    SharedEventManagerInterface $sharedEvents = null,\n    array $identifiers = []\n)  The  EventManager  instance accepts a shared event manager instance and\nidentifiers to use with the shared event manager.",
            "title": "Constructor"
        },
        {
            "location": "/api/#seteventprototype",
            "text": "public function setEventPrototype(EventInterface $event) : void  Use this method in order to provide an event prototype. The event prototype is\nused with the  trigger()  and  triggerUntil()  methods to create a new event\ninstance; the prototype is cloned and populated with the event name, target, and\narguments passed to the method.",
            "title": "setEventPrototype()"
        },
        {
            "location": "/api/#getsharedmanager",
            "text": "public function getSharedManager() : null|SharedEventManagerInterface  Use this method to retrieve the composed shared event manager instance, if any.",
            "title": "getSharedManager()"
        },
        {
            "location": "/api/#getidentifiers",
            "text": "public function getIdentifiers() : array  Use this method to retrieve the current list of identifiers the event manager\ndefines. Identifiers are used when retrieving listeners from the composed shared\nevent manager.",
            "title": "getIdentifiers()"
        },
        {
            "location": "/api/#setidentifiers-and-addidentifiers",
            "text": "public function setIdentifiers(array $identifiers) : void\npublic function addIdentifiers(array $identifiers) : void  Use these methods to manipulate the list of identifiers the event manager\nis interested in.  setIdentifiers()  will overwrite any identifiers previously\nset, while  addIdentifiers()  will merge them.",
            "title": "setIdentifiers() and addIdentifiers()"
        },
        {
            "location": "/api/#trigger",
            "text": "trigger($eventName, $target = null, $argv = []) : ResponseCollection  where:   $eventName  is a string event name.  $target  is the target of the event; usually the object composing the event\n  manager instance.  $argv  is an array or  ArrayAccess  instance of arguments that provide\n  context for the event. Typically these will be the arguments passed to the\n  function in which the trigger call occurs.   The target and/or arguments may be omitted, but the event name is required.  When done triggering, the method returns a  ResponseCollection .",
            "title": "trigger()"
        },
        {
            "location": "/api/#triggeruntil",
            "text": "triggerUntil(callable $callback, $eventName, $target = null, $argv = []) : ResponseCollection  triggerUntil()  is a sibling to  trigger() , and prefixes the argument list\nwith a single  $callback .  The  $callback  is invoked after each listener completes, with the result of\nthat listener. The  $callback  should inspect the result, and determine if it\nshould result in short-circuiting the event loop. Returning a boolean  true \nvalue indicates that the criteria has been met and the event loop should end.  As an example:  $events->attach('foo', function ($e) {\n    echo \"Triggered first\\n\";\n    return true;\n});\n$events->attach('foo', function ($e) {\n    echo \"Triggered second\\n\";\n    return false;\n});\n$events->attach('foo', function ($e) {\n    echo \"Triggered third\\n\";\n    return true;\n});\n\n$events->triggerUntil(function ($result) {\n    return (false === $result);\n}, 'foo');  In the above example, the event loop will short-circuit after the second\nlistener executes, resulting in the following output:  Triggered first\nTriggered second",
            "title": "triggerUntil()"
        },
        {
            "location": "/api/#triggerevent",
            "text": "triggerEvent(EventInterfce $event) : ResponseCollection  This method is a sibling to  trigger() , but unlike  trigger() , it accepts an EventInterface  instance as its sole argument. It is up to the caller to ensure\nthe event is properly populated.  This method behaves identically to  trigger() , returning a  ResponseCollection \nafter all listeners have been triggered.",
            "title": "triggerEvent()"
        },
        {
            "location": "/api/#triggereventuntil",
            "text": "triggerEventUntil(callable $callback, EventInterface $event) : ResponseCollection  This method is a sibling to  triggerEvent()  and  triggerUntil() . Like triggerUntil() , the first argument is a PHP callable to invoke for each\nresponse, and is used to determine whether or not to short-circuit execution.\nLike  triggerEvent() , the next argument is an  EventInterface  instance.",
            "title": "triggerEventUntil()"
        },
        {
            "location": "/api/#attach",
            "text": "attach($eventName, callable $listener, $priority = 1) : callable  Use  attach()  to attach a callable listener to a named event.  $priority  can\nbe used to indicate where in the listener queue the event should be executed.\nPriorities  must  be integers. High positive integers indicate higher priority\n(will execute first), while low, negative integers indicate lower priority (will\nexecute last). The default priority is 1, and listeners registered with the same\npriority will execute in the order in which they attach to the event manager.  The method returns the listener attached.",
            "title": "attach()"
        },
        {
            "location": "/api/#detach",
            "text": "detach(callable $listener, $eventName = null) : void  Use  detach()  to remove a listener. When a named  $eventName  is provided, the\nmethod will detach the listener from that event only (or, if the event does not\nexist in the event manager, nothing will occur). If no event is provided, or the\nwildcard event is provided, the listener will be detached from all events.",
            "title": "detach()"
        },
        {
            "location": "/api/#clearlisteners",
            "text": "clearListeners($eventName) : void  Use this method to remove all listeners for a given named event.",
            "title": "clearListeners()"
        },
        {
            "location": "/api/#prepareargs",
            "text": "prepareArgs(array $args) : ArrayObject  Normally when working with an event, if you want to change any arguments in the\nevent, you would need to do the following:  $args = $e->getParams();\n\n// Manipulate args:\n$args['foo'] = 'bar';\n\n// Pass them back in:\n$e->setParams($args);  If the arguments you provide are an  object , however, you can manipulate them\ndirectly:  $args = $e->getParams();\n\n// Manipulate args:\n$args->foo = 'bar';\n\n// Done!  Using an object, however, makes accessing individual parameters difficult:  $foo = $e->getParam('foo'); // How should the event know how to get this?  As such, we recommend passing either an array or an  ArrayObject  instance for\nevent arguments. If you pass the latter, you get the benefit of being able to\nmainpulate by reference.  prepareArgs()  can thus be used to return an  ArrayObject  representation of\nyour aguments to pass to  trigger()  or  triggerUntil() :  $events->attach('foo', $this, $events->prepareArgs(compact('bar', 'baz')));",
            "title": "prepareArgs()"
        },
        {
            "location": "/api/#sharedeventmanager",
            "text": "",
            "title": "SharedEventManager"
        },
        {
            "location": "/api/#attach_1",
            "text": "attach($identifier, $eventName, callable $listener, $priority = 1) : void  Attach a listener to a named event triggered by an identified context, where:   $identifier  is a string identifier that may be defined by an  EventManager \n  instance;  $identifier  may be the wildcard  * .  $eventName  is a string event name (or the wildcard  * ).  $listener  is a PHP callable that will listen for an event.  $priority  is the priority to use when attaching the listener.",
            "title": "attach()"
        },
        {
            "location": "/api/#detach_1",
            "text": "detach(callable $listener, $identifer = null, $eventName = null) : void  Detach a listener, optionally from a single identifier, and optionally from a\nnamed event, where:   $listener  is the PHP callable listener to detach.  $identifier  is a string identifier from which to detach.  $eventName  is a string event name from which to detach.   If no or a null  $identifier  is provided, the listener will be detached from all\nidentified contexts. If no or a null  $eventName  is provided, the listener will be\ndetached from all named events discovered.",
            "title": "detach()"
        },
        {
            "location": "/api/#getlisteners",
            "text": "getListeners(array $identifiers, $eventName = null) : array[]  Retrieves all registered listeners for a given identifier and named event; if\nthe event name is omitted, it returns all listeners for the identifier.  Each value in the array returned is in the form:  [\n    'listener' => callable,\n    'priority' => int,\n]  Implementations should return wildcard listeners in this array.  This method is used by the  EventManager  in order to get a set of listeners for\nthe event being triggered.",
            "title": "getListeners()"
        },
        {
            "location": "/api/#clearlisteners_1",
            "text": "clearListeners($id, $eventName = null) : bool  This event will clear all listeners for a given identifier, or, if specified,\nthe specific event for the named identifier.",
            "title": "clearListeners()"
        },
        {
            "location": "/api/#eventinterface",
            "text": "In most cases, you will use  Zend\\EventManager\\Event , but some components will\ndefine custom events. The  EventInterface  thus defines the common methods\nacross any event implementation.",
            "title": "EventInterface"
        },
        {
            "location": "/api/#getname",
            "text": "getName() : string  Returns the event name.",
            "title": "getName()"
        },
        {
            "location": "/api/#gettarget",
            "text": "getTarget() : null|string|object  Returns the event target, if any.",
            "title": "getTarget()"
        },
        {
            "location": "/api/#getparams",
            "text": "getParams() : array|ArrayAccess  Returns the event parameters, if any.",
            "title": "getParams()"
        },
        {
            "location": "/api/#getparam",
            "text": "getParam($name, $default = null) : mixed  Returns a single named parameter, returning the  $default  if not found.",
            "title": "getParam()"
        },
        {
            "location": "/api/#setname",
            "text": "setName($name) : void  Sets the event name.",
            "title": "setName()"
        },
        {
            "location": "/api/#settarget",
            "text": "setTarget($target) : void  Sets the event target.  $target  may be a string or object.",
            "title": "setTarget()"
        },
        {
            "location": "/api/#setparams",
            "text": "setParams($parms) : void  Set the event parameters;  $params  should be an array or object implementing ArrayAccess .",
            "title": "setParams()"
        },
        {
            "location": "/api/#setparam",
            "text": "setParam($name, $value) : void  Set a single named event parameter value.",
            "title": "setParam()"
        },
        {
            "location": "/api/#stoppropagation",
            "text": "stopPropagation($flag = true) : void  Indicate whether or not event propagation should halt (short-circuit). This\nvalue is what will be returned by  propagationIsStopped() .",
            "title": "stopPropagation()"
        },
        {
            "location": "/api/#propagationisstopped",
            "text": "propagationIsStopped() : bool  Used by the event manager to determine if the event has indicated that the event\nloop should short-circuit.",
            "title": "propagationIsStopped()"
        },
        {
            "location": "/api/#responsecollection",
            "text": "A  ResponseCollection  instance is returned by each of  trigger() , triggerUntil() ,  triggerEvent() , and  triggerEventUntil() , and represents\nthe various results of listener execution.  The  ResponseCollection  is iterable, and iteration will return the various\nresponses in the order in which they were provided. In addition, it has the API\nlisted below.",
            "title": "ResponseCollection"
        },
        {
            "location": "/api/#stopped",
            "text": "stopped() : bool  Use this to determine if something caused the event loop to short-circuit.",
            "title": "stopped()"
        },
        {
            "location": "/api/#first",
            "text": "first() : mixed  Returns the result from the first listener executed.",
            "title": "first()"
        },
        {
            "location": "/api/#last",
            "text": "last() : mixed  Returns the result from the last listener executed.",
            "title": "last()"
        },
        {
            "location": "/api/#contains",
            "text": "contains($value) : bool  Query the response collection to determine if a specific value was returned by\nany listener.",
            "title": "contains()"
        },
        {
            "location": "/intercepting-filters/",
            "text": "Intercepting Filters\n\n\nIntercepting filters\n are a\ndesign pattern used for providing mechanisms to alter the workflow of an\napplication. Implementing them provides a way to have a standard public\ninterface, with the ability to attach arbitrary numbers of filters that will\ntake the incoming arguments in order to alter the workflow.\n\n\nzend-eventmanager provides an intercepting filter implementation via\n\nZend\\EventManager\\FilterChain\n.\n\n\nPreparation\n\n\nTo use the \nFilterChain\n implementation, you will need to install zend-stdlib,\nif you have not already:\n\n\n$ composer require zendframework/zend-stdlib\n\n\n\n\nFilterChainInterface\n\n\nZend\\EventManager\\FilterChain\n is a concrete implementation of\n\nZend\\EventManager\\Filter\\FilterInterface\n, which defines a workflow for\nintercepting filters. This includes the following methods:\n\n\ninterface FilterInterface\n{\n    public function run($context, array $params = []);\n\n    public function attach(callable $callback);\n    public function detach(callable $callback);\n\n    public function getFilters();\n    public function clearFilters();\n    public function getResponses();\n}\n\n\n\n\nIn many ways, it's very similar to the \nEventManagerInterface\n, but with a few\nkey differences:\n\n\n\n\nA filter essentially defines a single event, which obviates the need for\n  attaching to multiple events. As such, you pass the target and parameters only\n  when \"triggering\" (\nrun()\n) a filter.\n\n\nInstead of passing an \nEventInterface\n to each attached filter, a\n  \nFilterInterface\n implementation will pass:\n\n\nThe \n$context\n\n\nThe \n$params\n\n\nA \nFilterIterator\n, to allow the listener to call on the next filter.\n\n\n\n\nFilterIterator\n\n\nWhen executing \nrun()\n, a \nFilterInterface\n implementation is expected to\nprovide the stack of attached filters to each listener. This stack will\ntypically be a \nZend\\EventManager\\Filter\\FilterIterator\n instance.\n\n\nFilterIterator\n extends \nZend\\Stdlib\\FastPriorityQueue\n, and, as such, is\niterable, and provides the method \nnext()\n for advancing the queue. \n\n\nAs such, a listener should decide if more processing is necessary, and, if so,\ncall on \n$chain->next()\n, passing the same set of arguments.\n\n\nFilters\n\n\nA filter attached to a \nFilterChain\n instance can be any callable. However,\nthese callables should expect the following arguments:\n\n\nfunction ($context, array $argv, FilterIterator $chain)\n\n\n\n\nA filter can therefore act on the provided \n$context\n, using the provided\narguments.\n\n\nPart of that execution can also be deciding that other filters should be called.\nTo do so, it will call \n$chain->next()\n, providing it the same arguments:\n\n\nfunction ($context, array $argv, FilterIterator $chain)\n{\n    $message = isset($argv['message']) ? $argv['message'] : '';\n\n    $message = str_rot13($message);\n\n    $filtered = $chain->next($context, ['message' => $message], $chain);\n\n    return str_rot13($filtered);\n}\n\n\n\n\nYou can choose to call \n$chain->next()\n at any point in the filter, allowing you\nto:\n\n\n\n\npre-process arguments and/or alter the state of the \n$context\n.\n\n\npost-process results and/or alter the state of the \n$context\n based on the\n  results.\n\n\nskip processing entirely if criteria is not met (e.g., missing arguments,\n  invalid \n$context\n state).\n\n\nshort-circuit the chain if no processing is necessary (e.g., a cache hit is\n  detected).\n\n\n\n\nExecution\n\n\nWhen executing a filter chain, you will provide the \n$context\n, which is usually\nthe object under observation, and arguments, which are typically the arguments\npassed to the method triggering the filter chain.\n\n\nAs an example, consider the following filter-enabled class:\n\n\nuse Zend\\EventManager\\FilterChain;\n\nclass ObservedTarget\n{\n    private $filters = [];\n\n    public function attachFilter($method, callable $listener)\n    {\n        if (! method_exists($this, $method)) {\n            throw new \\InvalidArgumentException('Invalid method');\n        }\n        $this->getFilters($method)->attach($listener);\n    }\n\n    public function execute($message)\n    {\n        return $this->getFilters(__FUNCTION__)\n            ->run($this, compact('message'));\n    }\n\n    private function getFilters($method)\n    {\n        if (! isset($this->filters[$method])) {\n            $this->filters[$method] = new FilterChain();\n        }\n        return $this->filters[$method];\n    }\n}\n\n\n\n\nNow, let's create an instance of the class, and attach some filters to it.\n\n\n$observed = new ObservedTarget();\n\n$observed->attach(function ($context, array $args, FilterIterator $chain) {\n    $args['message'] = isset($args['message'])\n        ? strtoupper($args['message'])\n        : '';\n\n    return $chain->next($context, $args, $chain);\n});\n\n$observed->attach(function ($context, array $args, FilterIterator $chain) {\n    return (isset($args['message'])\n        ? str_rot13($args['message'])\n        : '');\n});\n\n$observed->attach(function ($context, array $args, FilterIterator $chain) {\n    return (isset($args['message'])\n        ? strtolower($args['message'])\n        : '');\n});\n\n\n\n\nFinally, we'll call the method, and see what results we get:\n\n\n$observed->execute('Hello, world!');\n\n\n\n\nSince filters are run in the order in which they are attached, the following\nwill occur:\n\n\n\n\nThe first filter will transform our message into \nHELLO, WORLD!\n, and then\n  call on the next filter.\n\n\nThe second filter will apply a ROT13 transformation on the string and \nreturn\n\n  it: \n!DLROW ,OLLEH\n.\n\n\n\n\nBecause the second filter does not call \n$chain->next()\n, the third filter never\nexecutes.\n\n\nNotes\n\n\nWe recommend using the construct \nrun($this, compact(method argument names)\n\nwhen invoking a \nFilterChain\n. This makes the argument keys predictable inside\nfilters.\n\n\nWe also recommend putting the default logic for the method invoking the filter\nchain in a filter itself, and attaching it at invocation. This allows\nintercepting filters to replace the main logic, while still providing a default\npath. This might look like:\n\n\n// Assume that the class contains the `attachFilter()` implementation from above.\nclass ObservedTarget\n{\n    private $attached = [];\n\n    public function execute($message)\n    {\n        if (! isset($this->attached[__FUNCTION__])) {\n            $this->attachFilter(__FUNCTION__, $this->getExecuteFilter();\n        }\n\n        return $this->getFilters(__FUNCTION__)\n            ->run($this, compact('message'));\n    }\n\n    private function getExecuteFilter()\n    {\n        $this->attached['execute'] = true;\n        return function ($context, array $args, FilterIterator $chain) {\n            return $args['message'];\n        };\n    }\n}\n\n\n\n\nIntercepting filters are a powerful way to introduce aspect-oriented programming\nparadigms into your code, as well as general-purpose mechanisms for introducing\nplugins.",
            "title": "Intercepting Filters"
        },
        {
            "location": "/intercepting-filters/#intercepting-filters",
            "text": "Intercepting filters  are a\ndesign pattern used for providing mechanisms to alter the workflow of an\napplication. Implementing them provides a way to have a standard public\ninterface, with the ability to attach arbitrary numbers of filters that will\ntake the incoming arguments in order to alter the workflow.  zend-eventmanager provides an intercepting filter implementation via Zend\\EventManager\\FilterChain .",
            "title": "Intercepting Filters"
        },
        {
            "location": "/intercepting-filters/#preparation",
            "text": "To use the  FilterChain  implementation, you will need to install zend-stdlib,\nif you have not already:  $ composer require zendframework/zend-stdlib",
            "title": "Preparation"
        },
        {
            "location": "/intercepting-filters/#filterchaininterface",
            "text": "Zend\\EventManager\\FilterChain  is a concrete implementation of Zend\\EventManager\\Filter\\FilterInterface , which defines a workflow for\nintercepting filters. This includes the following methods:  interface FilterInterface\n{\n    public function run($context, array $params = []);\n\n    public function attach(callable $callback);\n    public function detach(callable $callback);\n\n    public function getFilters();\n    public function clearFilters();\n    public function getResponses();\n}  In many ways, it's very similar to the  EventManagerInterface , but with a few\nkey differences:   A filter essentially defines a single event, which obviates the need for\n  attaching to multiple events. As such, you pass the target and parameters only\n  when \"triggering\" ( run() ) a filter.  Instead of passing an  EventInterface  to each attached filter, a\n   FilterInterface  implementation will pass:  The  $context  The  $params  A  FilterIterator , to allow the listener to call on the next filter.",
            "title": "FilterChainInterface"
        },
        {
            "location": "/intercepting-filters/#filteriterator",
            "text": "When executing  run() , a  FilterInterface  implementation is expected to\nprovide the stack of attached filters to each listener. This stack will\ntypically be a  Zend\\EventManager\\Filter\\FilterIterator  instance.  FilterIterator  extends  Zend\\Stdlib\\FastPriorityQueue , and, as such, is\niterable, and provides the method  next()  for advancing the queue.   As such, a listener should decide if more processing is necessary, and, if so,\ncall on  $chain->next() , passing the same set of arguments.",
            "title": "FilterIterator"
        },
        {
            "location": "/intercepting-filters/#filters",
            "text": "A filter attached to a  FilterChain  instance can be any callable. However,\nthese callables should expect the following arguments:  function ($context, array $argv, FilterIterator $chain)  A filter can therefore act on the provided  $context , using the provided\narguments.  Part of that execution can also be deciding that other filters should be called.\nTo do so, it will call  $chain->next() , providing it the same arguments:  function ($context, array $argv, FilterIterator $chain)\n{\n    $message = isset($argv['message']) ? $argv['message'] : '';\n\n    $message = str_rot13($message);\n\n    $filtered = $chain->next($context, ['message' => $message], $chain);\n\n    return str_rot13($filtered);\n}  You can choose to call  $chain->next()  at any point in the filter, allowing you\nto:   pre-process arguments and/or alter the state of the  $context .  post-process results and/or alter the state of the  $context  based on the\n  results.  skip processing entirely if criteria is not met (e.g., missing arguments,\n  invalid  $context  state).  short-circuit the chain if no processing is necessary (e.g., a cache hit is\n  detected).",
            "title": "Filters"
        },
        {
            "location": "/intercepting-filters/#execution",
            "text": "When executing a filter chain, you will provide the  $context , which is usually\nthe object under observation, and arguments, which are typically the arguments\npassed to the method triggering the filter chain.  As an example, consider the following filter-enabled class:  use Zend\\EventManager\\FilterChain;\n\nclass ObservedTarget\n{\n    private $filters = [];\n\n    public function attachFilter($method, callable $listener)\n    {\n        if (! method_exists($this, $method)) {\n            throw new \\InvalidArgumentException('Invalid method');\n        }\n        $this->getFilters($method)->attach($listener);\n    }\n\n    public function execute($message)\n    {\n        return $this->getFilters(__FUNCTION__)\n            ->run($this, compact('message'));\n    }\n\n    private function getFilters($method)\n    {\n        if (! isset($this->filters[$method])) {\n            $this->filters[$method] = new FilterChain();\n        }\n        return $this->filters[$method];\n    }\n}  Now, let's create an instance of the class, and attach some filters to it.  $observed = new ObservedTarget();\n\n$observed->attach(function ($context, array $args, FilterIterator $chain) {\n    $args['message'] = isset($args['message'])\n        ? strtoupper($args['message'])\n        : '';\n\n    return $chain->next($context, $args, $chain);\n});\n\n$observed->attach(function ($context, array $args, FilterIterator $chain) {\n    return (isset($args['message'])\n        ? str_rot13($args['message'])\n        : '');\n});\n\n$observed->attach(function ($context, array $args, FilterIterator $chain) {\n    return (isset($args['message'])\n        ? strtolower($args['message'])\n        : '');\n});  Finally, we'll call the method, and see what results we get:  $observed->execute('Hello, world!');  Since filters are run in the order in which they are attached, the following\nwill occur:   The first filter will transform our message into  HELLO, WORLD! , and then\n  call on the next filter.  The second filter will apply a ROT13 transformation on the string and  return \n  it:  !DLROW ,OLLEH .   Because the second filter does not call  $chain->next() , the third filter never\nexecutes.",
            "title": "Execution"
        },
        {
            "location": "/intercepting-filters/#notes",
            "text": "We recommend using the construct  run($this, compact(method argument names) \nwhen invoking a  FilterChain . This makes the argument keys predictable inside\nfilters.  We also recommend putting the default logic for the method invoking the filter\nchain in a filter itself, and attaching it at invocation. This allows\nintercepting filters to replace the main logic, while still providing a default\npath. This might look like:  // Assume that the class contains the `attachFilter()` implementation from above.\nclass ObservedTarget\n{\n    private $attached = [];\n\n    public function execute($message)\n    {\n        if (! isset($this->attached[__FUNCTION__])) {\n            $this->attachFilter(__FUNCTION__, $this->getExecuteFilter();\n        }\n\n        return $this->getFilters(__FUNCTION__)\n            ->run($this, compact('message'));\n    }\n\n    private function getExecuteFilter()\n    {\n        $this->attached['execute'] = true;\n        return function ($context, array $args, FilterIterator $chain) {\n            return $args['message'];\n        };\n    }\n}  Intercepting filters are a powerful way to introduce aspect-oriented programming\nparadigms into your code, as well as general-purpose mechanisms for introducing\nplugins.",
            "title": "Notes"
        },
        {
            "location": "/migration/intro/",
            "text": "Migration\n\n\nIn this guide you will find specifics regarding changes from version 2 to\nversion 3 of zend-eventmanager, including recommendations for forward-proofing\nyour v2 applications such that they will work under v3.",
            "title": "Intro"
        },
        {
            "location": "/migration/intro/#migration",
            "text": "In this guide you will find specifics regarding changes from version 2 to\nversion 3 of zend-eventmanager, including recommendations for forward-proofing\nyour v2 applications such that they will work under v3.",
            "title": "Migration"
        },
        {
            "location": "/migration/removed/",
            "text": "Removed Functionality\n\n\nThe following interfaces, classes, and methods have been removed for version 3.\n\n\nGlobalEventManager and StaticEventManager\n\n\nZend\\EventManager\\GlobalEventManager\n and\n\nZend\\EventManager\\StaticEventManager\n were removed, and there are no\nreplacements.  Global static state is generally considered a dangerous practice\ndue to the side effects it can create, and we felt it was better to remove the\noption from the framework entirely.\n\n\nProvidesEvents\n\n\nThe trait \nZend\\EventManager\\ProvidesEvents\n has been deprecated for most of\nthe 2.0 series; use \nZend\\EventManager\\EventManagerAwareTrait\n instead.\n\n\nEventManagerInterface::setSharedManager()\n\n\nWe have removed \nEventManagerInterface::setSharedManager()\n, and also removed it\nfrom the \nEventManager\n implementation. The \nSharedEventManager\n should be\ninjected during instantiation now.\n\n\nEventManagerInterface::getEvents() and getListeners()\n\n\nWe have removed both \nEventManagerInterface::getEvents()\n and \ngetListeners()\n,\nas we did not have a stated use case for the methods. The event manager should\nbe something that aggregates listeners and triggers events; the details of what\nlisteners or events are attached is largely irrelevant.\n\n\nThe primary use case for \ngetListeners()\n is often to determine if a listener is\nattached before detaching it. Since \ndetach()\n acts as a no-op if the provided\nlistener is not present, checking for presence first is not necessary.\n\n\nEventManagerInterface::setEventClass()\n\n\nThe method \nEventManagerInterface::setEventClass()\n was removed and replaced\nwith \nEventManagerInterface::setEventPrototype()\n, which has the following\nsignature:\n\n\nsetEventPrototype(EventInterface $event);\n\n\n\n\nThis was done to prevent errors that occurred when invalid event class names\nwere provided. Additionally, internally, event managers will clone the\ninstance any time \ntrigger()\n or \ntriggerUntil()\n are called \u2014 which is\ntypically faster and less resource intensive than instantiating a new instance.\n\n\nEventManagerInterface::attachAggregate() and detachAggregate()\n\n\nThe methods \nattachAggregate()\n and \ndetachAggregate()\n were removed from the\n\nEventManagerInterface\n and concrete \nEventManager\n implementation. Furthermore,\n\nattach()\n and \ndetach()\n no longer handle aggregates.\n\n\nThe reason they were removed is because they simply proxied to the \nattach()\n\nand \ndetach()\n methods of the \nListenerAggregateInterface\n. As such, to\nforward-proof your applications, you can alter statements that attach aggregates\nto an event manager reading as follows:\n\n\n$events->attach($aggregate); // or\n$events->attachAggregate($aggregate);\n\n\n\n\nto:\n\n\n$aggregate->attach($events);\n\n\n\n\nSimilarly, for detaching an aggregate, migrate from:\n\n\n$events->detach($aggregate); // or\n$events->detachAggregate($aggregate);\n\n\n\n\nto:\n\n\n$aggregate->detach($events);\n\n\n\n\nThe above works in all released versions of the component.\n\n\nSharedEventAggregateAwareInterface, SharedListenerAggregateInterface\n\n\nThe interfaces \nZend\\EventManager\\SharedEventAggregateAwareInterface\n and\n\nSharedListenerAggregateInterface\n were removed, as the concept of shared\nlistener aggregates was removed from version 3.\n\n\nMigration will depend on what you have done in your application: extending\nthe \nSharedEventManager\n and/or implementing \nSharedEventAggregateAwareInterface\n,\nor implementing \nSharedListenerAggregateInterface\n.\n\n\nSharedEventAggregateAwareInterface\n\n\nZend\\EventManager\\SharedEventAggregateAwareInterface\n was added mid-way through\nthe v2 lifecycle to allow adding shared listener aggregates to the\n\nSharedEventManager\n. If you were extending the \nSharedEventManager\n and\noverriding the methods defined in \nSharedEventAggregateAwareInterface\n, you\nshould remove them.\n\n\nIf you were implementing \nSharedEventAggregateAwareInterface\n, the interface no\nlonger exists, and you should likely remove your implementation.\n\n\nSharedListenerAggregateInterface\n\n\nFor those implementing shared listener aggregates, you can continue to use them,\nbut will need to change how you do so.\n\n\nTo migrate, you have two steps to take: remove the\n\nSharedListenerAggregateInterface\n implementation declaration from your\naggregate class, and swap attachment of the aggregate.\n\n\nTo accomplish the first step, keep the \nattachShared()\n and \ndetachShared()\n\nmethods in your class, but remove the \nimplements\nSharedListenerAggregateInterface\n from the class declaration. For instance, if\nyou had the following:\n\n\nnamespace Foo;\n\nuse Zend\\EventManager\\SharedEventManagerInterface;\nuse Zend\\EventManager\\SharedListenerAggregateInterface;\n\nclass MySharedAggregate implements SharedListenerAggregateInterface\n{\n    public function attachShared(SharedEventManagerInterface $manager)\n    {\n        // ...\n    }\n\n    public function detachShared(SharedEventManagerInterface $manager)\n    {\n        // ...\n    }\n}\n\n\n\n\nthen modify it to instead read:\n\n\nnamespace Foo;\n\nuse Zend\\EventManager\\SharedEventManagerInterface;\n\nclass MySharedAggregate\n{\n    public function attachShared(SharedEventManagerInterface $manager)\n    {\n        // ...\n    }\n\n    public function detachShared(SharedEventManagerInterface $manager)\n    {\n        // ...\n    }\n}\n\n\n\n\nFor the second step, instead of attaching the aggregate to the shared event\nmanager, you will pass the shared event manager to your aggregate. For example,\nif you had the following in your code:\n\n\n$sharedEvents->attachAggregate($mySharedAggregate);\n\n\n\n\nthen you can change it to:\n\n\n$mySharedAggregate->attachShared($sharedEvents);\n\n\n\n\nThis has exactly the same effect, and makes your code forward-compatible with\nv3.\n\n\nSharedEventManagerAwareInterface\n\n\nThe interface \nZend\\EventManager\\SharedEventManagerAwareInterface\n was removed,\nas version 3 now requires tha the \nSharedEventManagerInterface\n instance be\ninjected into the \nEventManager\n instance at instantiation.\n\n\nA new interface, \nZend\\EventManager\\SharedEventsCapableInterface\n, provides the\n\ngetSharedManager()\n method, and \nEventManagerInterface\n extends it.\n\n\nTo migrate, you have the following options:\n\n\n\n\nIf you are only interested in the \ngetSharedManager()\n method, you can\n  implement \nSharedEventsCapableInterface\n starting with version 2.6.0. If you\n  do this, you can also safely remove the \nsetSharedManager()\n method from your\n  implementation.\n\n\nIf you will require injecting the shared manager, use duck typing to determine\n  if a class has the \nsetSharedManager()\n method:\n\n\n\n\nif (method_exists($instance, 'setSharedManager')) {\n    $instance->setSharedManager($sharedEvents);\n}\n\n\n\n\nAlternately, if you control instantiation of the instance, consider injection\n  at instantiation, or within the factory used to create your instance.\n\n\nSharedEventManagerInterface::getEvents()\n\n\nThe method \nSharedEventManagerInterface::getEvents()\n was removed. The method\nwas not consumed by the event manager, and served no real purpose.",
            "title": "Removed Functionality"
        },
        {
            "location": "/migration/removed/#removed-functionality",
            "text": "The following interfaces, classes, and methods have been removed for version 3.",
            "title": "Removed Functionality"
        },
        {
            "location": "/migration/removed/#globaleventmanager-and-staticeventmanager",
            "text": "Zend\\EventManager\\GlobalEventManager  and Zend\\EventManager\\StaticEventManager  were removed, and there are no\nreplacements.  Global static state is generally considered a dangerous practice\ndue to the side effects it can create, and we felt it was better to remove the\noption from the framework entirely.",
            "title": "GlobalEventManager and StaticEventManager"
        },
        {
            "location": "/migration/removed/#providesevents",
            "text": "The trait  Zend\\EventManager\\ProvidesEvents  has been deprecated for most of\nthe 2.0 series; use  Zend\\EventManager\\EventManagerAwareTrait  instead.",
            "title": "ProvidesEvents"
        },
        {
            "location": "/migration/removed/#eventmanagerinterfacesetsharedmanager",
            "text": "We have removed  EventManagerInterface::setSharedManager() , and also removed it\nfrom the  EventManager  implementation. The  SharedEventManager  should be\ninjected during instantiation now.",
            "title": "EventManagerInterface::setSharedManager()"
        },
        {
            "location": "/migration/removed/#eventmanagerinterfacegetevents-and-getlisteners",
            "text": "We have removed both  EventManagerInterface::getEvents()  and  getListeners() ,\nas we did not have a stated use case for the methods. The event manager should\nbe something that aggregates listeners and triggers events; the details of what\nlisteners or events are attached is largely irrelevant.  The primary use case for  getListeners()  is often to determine if a listener is\nattached before detaching it. Since  detach()  acts as a no-op if the provided\nlistener is not present, checking for presence first is not necessary.",
            "title": "EventManagerInterface::getEvents() and getListeners()"
        },
        {
            "location": "/migration/removed/#eventmanagerinterfaceseteventclass",
            "text": "The method  EventManagerInterface::setEventClass()  was removed and replaced\nwith  EventManagerInterface::setEventPrototype() , which has the following\nsignature:  setEventPrototype(EventInterface $event);  This was done to prevent errors that occurred when invalid event class names\nwere provided. Additionally, internally, event managers will clone the\ninstance any time  trigger()  or  triggerUntil()  are called \u2014 which is\ntypically faster and less resource intensive than instantiating a new instance.",
            "title": "EventManagerInterface::setEventClass()"
        },
        {
            "location": "/migration/removed/#eventmanagerinterfaceattachaggregate-and-detachaggregate",
            "text": "The methods  attachAggregate()  and  detachAggregate()  were removed from the EventManagerInterface  and concrete  EventManager  implementation. Furthermore, attach()  and  detach()  no longer handle aggregates.  The reason they were removed is because they simply proxied to the  attach() \nand  detach()  methods of the  ListenerAggregateInterface . As such, to\nforward-proof your applications, you can alter statements that attach aggregates\nto an event manager reading as follows:  $events->attach($aggregate); // or\n$events->attachAggregate($aggregate);  to:  $aggregate->attach($events);  Similarly, for detaching an aggregate, migrate from:  $events->detach($aggregate); // or\n$events->detachAggregate($aggregate);  to:  $aggregate->detach($events);  The above works in all released versions of the component.",
            "title": "EventManagerInterface::attachAggregate() and detachAggregate()"
        },
        {
            "location": "/migration/removed/#sharedeventaggregateawareinterface-sharedlisteneraggregateinterface",
            "text": "The interfaces  Zend\\EventManager\\SharedEventAggregateAwareInterface  and SharedListenerAggregateInterface  were removed, as the concept of shared\nlistener aggregates was removed from version 3.  Migration will depend on what you have done in your application: extending\nthe  SharedEventManager  and/or implementing  SharedEventAggregateAwareInterface ,\nor implementing  SharedListenerAggregateInterface .",
            "title": "SharedEventAggregateAwareInterface, SharedListenerAggregateInterface"
        },
        {
            "location": "/migration/removed/#sharedeventaggregateawareinterface",
            "text": "Zend\\EventManager\\SharedEventAggregateAwareInterface  was added mid-way through\nthe v2 lifecycle to allow adding shared listener aggregates to the SharedEventManager . If you were extending the  SharedEventManager  and\noverriding the methods defined in  SharedEventAggregateAwareInterface , you\nshould remove them.  If you were implementing  SharedEventAggregateAwareInterface , the interface no\nlonger exists, and you should likely remove your implementation.",
            "title": "SharedEventAggregateAwareInterface"
        },
        {
            "location": "/migration/removed/#sharedlisteneraggregateinterface",
            "text": "For those implementing shared listener aggregates, you can continue to use them,\nbut will need to change how you do so.  To migrate, you have two steps to take: remove the SharedListenerAggregateInterface  implementation declaration from your\naggregate class, and swap attachment of the aggregate.  To accomplish the first step, keep the  attachShared()  and  detachShared() \nmethods in your class, but remove the  implements\nSharedListenerAggregateInterface  from the class declaration. For instance, if\nyou had the following:  namespace Foo;\n\nuse Zend\\EventManager\\SharedEventManagerInterface;\nuse Zend\\EventManager\\SharedListenerAggregateInterface;\n\nclass MySharedAggregate implements SharedListenerAggregateInterface\n{\n    public function attachShared(SharedEventManagerInterface $manager)\n    {\n        // ...\n    }\n\n    public function detachShared(SharedEventManagerInterface $manager)\n    {\n        // ...\n    }\n}  then modify it to instead read:  namespace Foo;\n\nuse Zend\\EventManager\\SharedEventManagerInterface;\n\nclass MySharedAggregate\n{\n    public function attachShared(SharedEventManagerInterface $manager)\n    {\n        // ...\n    }\n\n    public function detachShared(SharedEventManagerInterface $manager)\n    {\n        // ...\n    }\n}  For the second step, instead of attaching the aggregate to the shared event\nmanager, you will pass the shared event manager to your aggregate. For example,\nif you had the following in your code:  $sharedEvents->attachAggregate($mySharedAggregate);  then you can change it to:  $mySharedAggregate->attachShared($sharedEvents);  This has exactly the same effect, and makes your code forward-compatible with\nv3.",
            "title": "SharedListenerAggregateInterface"
        },
        {
            "location": "/migration/removed/#sharedeventmanagerawareinterface",
            "text": "The interface  Zend\\EventManager\\SharedEventManagerAwareInterface  was removed,\nas version 3 now requires tha the  SharedEventManagerInterface  instance be\ninjected into the  EventManager  instance at instantiation.  A new interface,  Zend\\EventManager\\SharedEventsCapableInterface , provides the getSharedManager()  method, and  EventManagerInterface  extends it.  To migrate, you have the following options:   If you are only interested in the  getSharedManager()  method, you can\n  implement  SharedEventsCapableInterface  starting with version 2.6.0. If you\n  do this, you can also safely remove the  setSharedManager()  method from your\n  implementation.  If you will require injecting the shared manager, use duck typing to determine\n  if a class has the  setSharedManager()  method:   if (method_exists($instance, 'setSharedManager')) {\n    $instance->setSharedManager($sharedEvents);\n}  Alternately, if you control instantiation of the instance, consider injection\n  at instantiation, or within the factory used to create your instance.",
            "title": "SharedEventManagerAwareInterface"
        },
        {
            "location": "/migration/removed/#sharedeventmanagerinterfacegetevents",
            "text": "The method  SharedEventManagerInterface::getEvents()  was removed. The method\nwas not consumed by the event manager, and served no real purpose.",
            "title": "SharedEventManagerInterface::getEvents()"
        },
        {
            "location": "/migration/changed/",
            "text": "Changed Functionality\n\n\nThe following methods had changes in signatures.\n\n\nEventManager::__construct()\n\n\nIn version 2, the signature of \n__construct()\n was:\n\n\n__construct($identifiers = null)\n\n\n\n\nwhere \n$identifiers\n could be a string, array of strings, or \nTraversable\n of\nstrings.\n\n\nVersion 3 requires that the shared event manager be injected at instantiation,\ninstead of via a setter. This also enforces the idea that identifiers have no\nsemantic meaning without a shared event manager composed. As such, the\nconstructor now has two arguments, with the first being the shared event\nmanager:\n\n\n__construct(SharedEventManagerInterface $sharedEvents, array $identifiers = [])\n\n\n\n\nFinally, because we changed the signature of \nsetIdentifiers()\n and\n\naddIdentifiers()\n to only accept arrays (see more below), we changed the\n\n$identifiers\n argument to only allow arrays.\n\n\nEventManagerInterface::trigger() and triggerUntil()\n\n\nIn version 2, the signatures of \ntrigger()\n and \ntriggerUntil()\n are:\n\n\ntrigger($event, $target = null, $argv = [], $callback = null);\ntriggerUntil($event, $target = null, $argv = [], $callback = null);\n\n\n\n\nThe methods allow overloading essentially every argument:\n\n\n\n\n$event\n could be the event name, array or traversable of event names,  or an\n  \nEventInterface\n instance.\n\n\n$target\n could be a callable representing the short-circuit callback, an\n  \nEventInterface\n instance, or a value representing the target of the event.\n\n\n$argv\n could be a callable representing the short-circuit callback, an\n  \nEventInterface\n instance, or an array/\nArrayAccess\n/object instance\n  representing the event arguments.\n\n\n$callback\n could be either \nnull\n or a callable.\n\n\n\n\nThe amount of overloading leads to:\n\n\n\n\n4 x 3 x 3 = 36 permutations of arguments, leading to confusion about how to\n  call the method.\n\n\nDozens of lines used to validate and marshal arguments.\n\n\n\n\nIn version 3, we changed the methods to have the following signatures:\n\n\ntrigger($event, $target = null, $argv = []);\ntriggerUntil(callable $callback, $event, $target = null, $argv = []);\n\n\n\n\nwith the following defintions:\n\n\n\n\n$event\n is a string event name.\n\n\n$target\n is a value representing the target of the event.\n\n\n$argv\n is an array/\nArrayAccess\n/object instance representing the event\n  arguments.\n\n\n$callback\n is a callable to use to introspect listener return values in order\n  to determine whether or not to short-circuit.\n\n\n\n\nIn other words, each argument has exactly one possible type. \n$callback\n was\nmoved to the start of the \ntriggerUntil()\n method as it's \nrequired\n for that\nusage, and ensures the argument order stays predictable for the remaining\narguments.\n\n\nIn order to accommodate other styles of usage, we \nadded\n the following\nmethods:\n\n\ntriggerUntil(callable $callback, $event, $target = null, $argv = []);\ntriggerEvent(EventInterface $event);\ntriggerEventUntil(callable $callback, EventInterface $event);\n\n\n\n\nThese allow the other primary use cases for \ntrigger()\n in v2, but with discrete\nsignatures.\n\n\nStarting in version 2.6.0, you can use these three additional methods, as the\n\nEventManager\n instance defines them starting in that version. We recommend\nevaluating your code to see which of the four possible call styles you are\nusing, and that you adapt your code to use one of the 4 discrete methods.\n\n\nThe following signatures, however, are no longer supported, and will need to be\nupdated as illustrated:\n\n\n// Event instance as second argument:\n$events->trigger('foo', $event);\n\n// Resolve by setting the event name prior to trigger:\n$event->setName('foo');\n$events->triggerEvent($event);\n\n// Event instance as third argument:\n$events->trigger('foo', $this, $event);\n\n// Resolve by setting the event name and target prior to trigger:\n$event->setName('foo');\n$event->setTarget($this);\n$events->triggerEvent($event);\n\n\n\n\nIf you are using a callback to shortcircuit, use one of the \n*Until()\n methods,\npassing the callback as the first argument:\n\n\n// Standard trigger:\n$events->trigger('foo', $this, ['bar' => 'baz'], $criteria);\n\n// becomes:\n$events->triggerUntil($criteria, 'foo', $this, ['bar' => 'baz']);\n\n// Triggering with an event:\n$events->trigger($event, $criteria);\n\n// becomes:\n$events->triggerEventUntil($criteria, $event);\n\n\n\n\nEventManagerInterface::attach() and detach()\n\n\nIn version 2, \nattach()\n and \ndetach()\n had the following signatures:\n\n\nattach($event, $callback = null, $priority = null);\ndetach($listener);\n\n\n\n\nwith the following argument definitions:\n\n\n\n\n$event\n could be either a string event name, or an instance of\n  \nListenerAggregateInterface\n.\n\n\n$callback\n could be a callable, an instance of \nZend\\Stdlib\\CallbackHandler\n,\n  or an integer priority (if \n$event\n was an aggregate).\n\n\n$priority\n could be null or an integer.\n\n\n$listener\n could be either a \nZend\\Stdlib\\CallbackHandler\n (as that was how\n  listeners were stored internally in that version), or an instance of\n  \nListenerAggregateInterface\n.\n\n\n\n\nMuch like we did for the \ntrigger*()\n methods, we simplified the signatures:\n\n\nattach($event, callable $listener, $priority = 1);\ndetach(callable $listener, $event = null);\n\n\n\n\nWhere:\n\n\n\n\n$event\n is always a string event name (except when not passed to \ndetach()\n.\n\n\n$listener\n is always the \ncallable\n listener.\n\n\n$priority\n is always an integer.\n\n\n\n\ndetach()\n adds the \n$event\n argument as the event argument for a couple of\nreasons. First, in version 2, the event was composed in the \nCallbackHandler\n,\nwhich meant it didn't need to be sent separately; since the event managers now\nstore the listeners directly, you \nmust\n pass the \n$event\n if you want to detach\nfrom a specific event. This leads to the second reason: by omitting the\nargument, you can now remove a listener from \nall\n events to which it is\nattached \u2014 a new capability for version 3.\n\n\nIn order to migrate to version 3, you will need to make a few changes to your\napplication.\n\n\nFirst, if you are attaching or detaching aggregate listeners using \nattach()\n\nand \ndetach()\n, you should change such calls to instead pass the event manager\nto the relevant \nListenerAggregateInterface\n method, as detailed in the\n\nremoved functionality\n\ndocumentation. These methods have existed in all released versions, giving\nperfect forwards compatibility.\n\n\nSecond, if you are manually creating \nCallbackHandler\n instances to attach to an\nevent manager, stop doing so, and attach the callable listener itself instead.\nThis, too, is completely forwards compatible.\n\n\nIf you are passing \nCallbackHandler\n instances to \ndetach()\n, you will need to\nmake the following change after updating to version 3:\n\n\n// This code:\n$events->detach($callbackHandler);\n\n// Will become:\n$events->detach($callbackHandler->getCallback());\n\n\n\n\nIn most cases, the callback handler you are storing is likely the result of\ncalling \nattach()\n in the first place. Since \nattach()\n no longer creates a\n\nCallbackHandler\n instance, it instead simply returns the listener back to the\ncaller. If you were storing this to pass later to \ndetach()\n (such as in a\nlistener aggregate), you will not need to make any changes when migrating.\n\n\nEventManagerInterface::setEventClass() and setEventPrototype()\n\n\nsetEventClass()\n was renamed to \nsetEventPrototype()\n and given a new\nsignature; see the \nsetEventClass() removal information\n\nfor details.\n\n\nEventManagerInterface::setIdentifiers() and addIdentifiers()\n\n\nEventManagerInterface::setIdentifiers()\n and \naddIdentifiers()\n had a minor\nsignature change. In version 2, the \n$identifiers\n argument allowed any of\n\nstring\n, \narray\n, or \nTraversable\n. In version 3, only arrays are allowed.\n\n\nAdditionally, neither implements a fluent interface any longer; you cannot chain\ntheir calls.\n\n\nSharedEventManagerInterface::getListeners()\n\n\nZend\\EventManager\\SharedEventManagerInterface::getListeners()\n has changed. The\nprevious signature was:\n\n\ngetListeners($id, $event = null): false|Zend\\Stdlib\\PriorityQueue\n\n\n\n\nVersion 3 has the following signature:\n\n\ngetListeners(array $identifiers, $eventName) : array\n\n\n\n\nThe changes are:\n\n\n\n\nThe first argument now expects an \narray\n of identifiers. This is so an event\n  manager instance can retrieve shared listeners for all identifiers it defines\n  at once.\n\n\nThe second argument is now \nrequired\n. Since the event manager always knows\n  the event at the time it calls the method, it makes sense to require the\n  argument for all calls. It also reduces complexity in the implementation.\n\n\nThe method now \nalways\n returns an array. The array will be of the structure\n  \n[ 'priority' => callable[] ]\n.\n\n\n\n\nSharedEventManagerInterface::attach()\n\n\nThe v2 signature of \nattach()\n was:\n\n\nattach($id, $event, $callback, $priority = 1) : CallbackHandler|CallbackHandler[]\n\n\n\n\nwhere:\n\n\n\n\n$id\n could be a string identifier, or an array or \nTraversable\n of\n  identifiers.\n\n\n$event\n was a string event name.\n\n\n$callback\n could be either a \ncallable\n listener, or a \nCallbackHandler\n\n  instance.\n\n\n$priority\n was an integer.\n\n\n\n\nThe v3 signature becomes:\n\n\nattach($identifier, $eventName, callable $listener, $priority = 1) : void\n\n\n\n\nwhere:\n\n\n\n\n$identifier\n \nmust\n be a string \nonly\n.\n\n\n$eventName\n must be a string name.\n\n\n$listener\n must be a callable \nonly\n.\n\n\n$priority\n is an integer.\n\n\n\n\nMigration concerns are thus:\n\n\n\n\nIf you are passing arrays of identifiers to which to attach, you must now do\n  so in a loop or using a construct such as \narray_walk\n:\n\n\n\n\nforeach ($identifiers as $id) {\n    $sharedEvents->attach($id, $event, $listener);\n}\n\narray_walk($identifiers, function ($id) use ($listener) {\n    $this->sharedEvents->attach($id, 'foo', $listener);\n});\n\n\n\n\n\n\n\n\nIf you are passing \nCallbackHandler\n arguments, pass the callable listener\n  instead.\n\n\n\n\n\n\nIf you were relying on being returned the \nCallbackHandler\n, you may now\n  simply cache the \n$listener\n argument.\n\n\n\n\n\n\nSharedEventManagerInterface::detach()\n\n\nThe v2 signature of \ndetach()\n was:\n\n\ndetach($id, CallbackHandler $listener) : bool\n\n\n\n\nwhere:\n\n\n\n\n$id\n was a string identifier\n\n\n$listener\n was a \nCallbackHandler\n instance\n\n\nthe method returned a boolean indicating whether or not it removed anything.\n\n\n\n\nThe v3 signature becomes:\n\n\ndetach(callable $listener, $identifier = null, $eventName = null) : void\n\n\n\n\nwhere:\n\n\n\n\n$listener\n is the callable listener you wish to remove\n\n\n$identifier\n, if provided, is a specific identifier from which you want to remove the\n  \n$listener\n.\n\n\n$eventName\n, if provided, is a specific event on the specified \n$id\n from\n  which to remove the \n$listener\n\n\nthe method no longer returns a value.\n\n\n\n\nWhen not specifying an identifier, the method contract indicates it should\nremove the listener from any identifier; similarly, in the absence of an event\nargument, it should remove the listener from any event on the identifier(s).\nThis allows for mass removal!\n\n\nAs the signatures differ, you will need to update any code calling \ndetach()\n\nafter upgrading to v3. At the minimum, you will need to swap the \n$identifier\n and\n\n$listener\n arguments, and pass the callable listener instead of a\n\nCallbackHandler\n instance. We also recommend auditing your code to determine if\nyou want to be more or less specific when detaching the listener.\n\n\nListenerAggregateInterface::attach()\n\n\nZend\\EventManager\\ListenerAggregateInterface::attach()\n was updated to add an\noptional argument, \n$priority = 1\n. This codifies how the \nEventManager\n was\nalready implemented.\n\n\nSince PHP allows adding optional arguments to concrete implementations of\nabstract methods, you can forward-proof your existing\n\nListenerAggregateInterface\n implementations by adding the argument.\n\n\nAs an example, if you define your method like this:\n\n\npublic function attach(EventManagerInterface $events)\n\n\n\n\nSimply change it to this:\n\n\npublic function attach(EventManagerInterface $events, $priority = 1)\n\n\n\n\nYou do not need to do anything with the \n$priority\n argument, though we\nrecommend passing it as a default value if you are not specifying a priority for\nany listeners you attach.\n\n\nFilterInterface::attach() and detach()\n\n\nZend\\EventManager\\Filter\\FilterInterface::attach()\n and \ndetach()\n have changed\nsignatures. The originals were:\n\n\nattach($callback) : CallbackHandler\ndetach(CallbackHandler $callback) : bool\n\n\n\n\nwhere \n$callback\n for \nattach()\n could be a callable or a \nCallbackHandler\n. The\nnew signatures are:\n\n\nattach(callable $callback) : void\ndetach(callable $filter) : bool\n\n\n\n\nTypical usage in v2 was to capture the return value of \nattach()\n and pass it to\n\ndetach()\n, as \nattach()\n would create a \nCallbackHandler\n for you to later pass\nto \ndetach()\n. Since we can now pass the original callable argument to\n\ndetach()\n now, you can cache that value instead.\n\n\nFilterIterator\n\n\nZend\\EventManager\\Filter\\FilterIterator\n now defines/overrides the \ninsert()\n\nmethod in order to validate the incoming value and ensure it is callable,\nraising an exception when it is not. This simplifies logic in \nFilterChain\n, as\nit no longer needs to check if a filter is callable at runtime.\n\n\nThe main migration change at this time is to know that an\n\nInvalidArgumentException\n will now be thrown when adding filters to a filter\nchain, vs at runtime.\n\n\nResponseCollection::setStopped()\n\n\nZend\\EventManager\\ResponseCollection::setStopped()\n no longer implements a\nfluent interface.",
            "title": "Changed Functionality"
        },
        {
            "location": "/migration/changed/#changed-functionality",
            "text": "The following methods had changes in signatures.",
            "title": "Changed Functionality"
        },
        {
            "location": "/migration/changed/#eventmanager__construct",
            "text": "In version 2, the signature of  __construct()  was:  __construct($identifiers = null)  where  $identifiers  could be a string, array of strings, or  Traversable  of\nstrings.  Version 3 requires that the shared event manager be injected at instantiation,\ninstead of via a setter. This also enforces the idea that identifiers have no\nsemantic meaning without a shared event manager composed. As such, the\nconstructor now has two arguments, with the first being the shared event\nmanager:  __construct(SharedEventManagerInterface $sharedEvents, array $identifiers = [])  Finally, because we changed the signature of  setIdentifiers()  and addIdentifiers()  to only accept arrays (see more below), we changed the $identifiers  argument to only allow arrays.",
            "title": "EventManager::__construct()"
        },
        {
            "location": "/migration/changed/#eventmanagerinterfacetrigger-and-triggeruntil",
            "text": "In version 2, the signatures of  trigger()  and  triggerUntil()  are:  trigger($event, $target = null, $argv = [], $callback = null);\ntriggerUntil($event, $target = null, $argv = [], $callback = null);  The methods allow overloading essentially every argument:   $event  could be the event name, array or traversable of event names,  or an\n   EventInterface  instance.  $target  could be a callable representing the short-circuit callback, an\n   EventInterface  instance, or a value representing the target of the event.  $argv  could be a callable representing the short-circuit callback, an\n   EventInterface  instance, or an array/ ArrayAccess /object instance\n  representing the event arguments.  $callback  could be either  null  or a callable.   The amount of overloading leads to:   4 x 3 x 3 = 36 permutations of arguments, leading to confusion about how to\n  call the method.  Dozens of lines used to validate and marshal arguments.   In version 3, we changed the methods to have the following signatures:  trigger($event, $target = null, $argv = []);\ntriggerUntil(callable $callback, $event, $target = null, $argv = []);  with the following defintions:   $event  is a string event name.  $target  is a value representing the target of the event.  $argv  is an array/ ArrayAccess /object instance representing the event\n  arguments.  $callback  is a callable to use to introspect listener return values in order\n  to determine whether or not to short-circuit.   In other words, each argument has exactly one possible type.  $callback  was\nmoved to the start of the  triggerUntil()  method as it's  required  for that\nusage, and ensures the argument order stays predictable for the remaining\narguments.  In order to accommodate other styles of usage, we  added  the following\nmethods:  triggerUntil(callable $callback, $event, $target = null, $argv = []);\ntriggerEvent(EventInterface $event);\ntriggerEventUntil(callable $callback, EventInterface $event);  These allow the other primary use cases for  trigger()  in v2, but with discrete\nsignatures.  Starting in version 2.6.0, you can use these three additional methods, as the EventManager  instance defines them starting in that version. We recommend\nevaluating your code to see which of the four possible call styles you are\nusing, and that you adapt your code to use one of the 4 discrete methods.  The following signatures, however, are no longer supported, and will need to be\nupdated as illustrated:  // Event instance as second argument:\n$events->trigger('foo', $event);\n\n// Resolve by setting the event name prior to trigger:\n$event->setName('foo');\n$events->triggerEvent($event);\n\n// Event instance as third argument:\n$events->trigger('foo', $this, $event);\n\n// Resolve by setting the event name and target prior to trigger:\n$event->setName('foo');\n$event->setTarget($this);\n$events->triggerEvent($event);  If you are using a callback to shortcircuit, use one of the  *Until()  methods,\npassing the callback as the first argument:  // Standard trigger:\n$events->trigger('foo', $this, ['bar' => 'baz'], $criteria);\n\n// becomes:\n$events->triggerUntil($criteria, 'foo', $this, ['bar' => 'baz']);\n\n// Triggering with an event:\n$events->trigger($event, $criteria);\n\n// becomes:\n$events->triggerEventUntil($criteria, $event);",
            "title": "EventManagerInterface::trigger() and triggerUntil()"
        },
        {
            "location": "/migration/changed/#eventmanagerinterfaceattach-and-detach",
            "text": "In version 2,  attach()  and  detach()  had the following signatures:  attach($event, $callback = null, $priority = null);\ndetach($listener);  with the following argument definitions:   $event  could be either a string event name, or an instance of\n   ListenerAggregateInterface .  $callback  could be a callable, an instance of  Zend\\Stdlib\\CallbackHandler ,\n  or an integer priority (if  $event  was an aggregate).  $priority  could be null or an integer.  $listener  could be either a  Zend\\Stdlib\\CallbackHandler  (as that was how\n  listeners were stored internally in that version), or an instance of\n   ListenerAggregateInterface .   Much like we did for the  trigger*()  methods, we simplified the signatures:  attach($event, callable $listener, $priority = 1);\ndetach(callable $listener, $event = null);  Where:   $event  is always a string event name (except when not passed to  detach() .  $listener  is always the  callable  listener.  $priority  is always an integer.   detach()  adds the  $event  argument as the event argument for a couple of\nreasons. First, in version 2, the event was composed in the  CallbackHandler ,\nwhich meant it didn't need to be sent separately; since the event managers now\nstore the listeners directly, you  must  pass the  $event  if you want to detach\nfrom a specific event. This leads to the second reason: by omitting the\nargument, you can now remove a listener from  all  events to which it is\nattached \u2014 a new capability for version 3.  In order to migrate to version 3, you will need to make a few changes to your\napplication.  First, if you are attaching or detaching aggregate listeners using  attach() \nand  detach() , you should change such calls to instead pass the event manager\nto the relevant  ListenerAggregateInterface  method, as detailed in the removed functionality \ndocumentation. These methods have existed in all released versions, giving\nperfect forwards compatibility.  Second, if you are manually creating  CallbackHandler  instances to attach to an\nevent manager, stop doing so, and attach the callable listener itself instead.\nThis, too, is completely forwards compatible.  If you are passing  CallbackHandler  instances to  detach() , you will need to\nmake the following change after updating to version 3:  // This code:\n$events->detach($callbackHandler);\n\n// Will become:\n$events->detach($callbackHandler->getCallback());  In most cases, the callback handler you are storing is likely the result of\ncalling  attach()  in the first place. Since  attach()  no longer creates a CallbackHandler  instance, it instead simply returns the listener back to the\ncaller. If you were storing this to pass later to  detach()  (such as in a\nlistener aggregate), you will not need to make any changes when migrating.",
            "title": "EventManagerInterface::attach() and detach()"
        },
        {
            "location": "/migration/changed/#eventmanagerinterfaceseteventclass-and-seteventprototype",
            "text": "setEventClass()  was renamed to  setEventPrototype()  and given a new\nsignature; see the  setEventClass() removal information \nfor details.",
            "title": "EventManagerInterface::setEventClass() and setEventPrototype()"
        },
        {
            "location": "/migration/changed/#eventmanagerinterfacesetidentifiers-and-addidentifiers",
            "text": "EventManagerInterface::setIdentifiers()  and  addIdentifiers()  had a minor\nsignature change. In version 2, the  $identifiers  argument allowed any of string ,  array , or  Traversable . In version 3, only arrays are allowed.  Additionally, neither implements a fluent interface any longer; you cannot chain\ntheir calls.",
            "title": "EventManagerInterface::setIdentifiers() and addIdentifiers()"
        },
        {
            "location": "/migration/changed/#sharedeventmanagerinterfacegetlisteners",
            "text": "Zend\\EventManager\\SharedEventManagerInterface::getListeners()  has changed. The\nprevious signature was:  getListeners($id, $event = null): false|Zend\\Stdlib\\PriorityQueue  Version 3 has the following signature:  getListeners(array $identifiers, $eventName) : array  The changes are:   The first argument now expects an  array  of identifiers. This is so an event\n  manager instance can retrieve shared listeners for all identifiers it defines\n  at once.  The second argument is now  required . Since the event manager always knows\n  the event at the time it calls the method, it makes sense to require the\n  argument for all calls. It also reduces complexity in the implementation.  The method now  always  returns an array. The array will be of the structure\n   [ 'priority' => callable[] ] .",
            "title": "SharedEventManagerInterface::getListeners()"
        },
        {
            "location": "/migration/changed/#sharedeventmanagerinterfaceattach",
            "text": "The v2 signature of  attach()  was:  attach($id, $event, $callback, $priority = 1) : CallbackHandler|CallbackHandler[]  where:   $id  could be a string identifier, or an array or  Traversable  of\n  identifiers.  $event  was a string event name.  $callback  could be either a  callable  listener, or a  CallbackHandler \n  instance.  $priority  was an integer.   The v3 signature becomes:  attach($identifier, $eventName, callable $listener, $priority = 1) : void  where:   $identifier   must  be a string  only .  $eventName  must be a string name.  $listener  must be a callable  only .  $priority  is an integer.   Migration concerns are thus:   If you are passing arrays of identifiers to which to attach, you must now do\n  so in a loop or using a construct such as  array_walk :   foreach ($identifiers as $id) {\n    $sharedEvents->attach($id, $event, $listener);\n}\n\narray_walk($identifiers, function ($id) use ($listener) {\n    $this->sharedEvents->attach($id, 'foo', $listener);\n});    If you are passing  CallbackHandler  arguments, pass the callable listener\n  instead.    If you were relying on being returned the  CallbackHandler , you may now\n  simply cache the  $listener  argument.",
            "title": "SharedEventManagerInterface::attach()"
        },
        {
            "location": "/migration/changed/#sharedeventmanagerinterfacedetach",
            "text": "The v2 signature of  detach()  was:  detach($id, CallbackHandler $listener) : bool  where:   $id  was a string identifier  $listener  was a  CallbackHandler  instance  the method returned a boolean indicating whether or not it removed anything.   The v3 signature becomes:  detach(callable $listener, $identifier = null, $eventName = null) : void  where:   $listener  is the callable listener you wish to remove  $identifier , if provided, is a specific identifier from which you want to remove the\n   $listener .  $eventName , if provided, is a specific event on the specified  $id  from\n  which to remove the  $listener  the method no longer returns a value.   When not specifying an identifier, the method contract indicates it should\nremove the listener from any identifier; similarly, in the absence of an event\nargument, it should remove the listener from any event on the identifier(s).\nThis allows for mass removal!  As the signatures differ, you will need to update any code calling  detach() \nafter upgrading to v3. At the minimum, you will need to swap the  $identifier  and $listener  arguments, and pass the callable listener instead of a CallbackHandler  instance. We also recommend auditing your code to determine if\nyou want to be more or less specific when detaching the listener.",
            "title": "SharedEventManagerInterface::detach()"
        },
        {
            "location": "/migration/changed/#listeneraggregateinterfaceattach",
            "text": "Zend\\EventManager\\ListenerAggregateInterface::attach()  was updated to add an\noptional argument,  $priority = 1 . This codifies how the  EventManager  was\nalready implemented.  Since PHP allows adding optional arguments to concrete implementations of\nabstract methods, you can forward-proof your existing ListenerAggregateInterface  implementations by adding the argument.  As an example, if you define your method like this:  public function attach(EventManagerInterface $events)  Simply change it to this:  public function attach(EventManagerInterface $events, $priority = 1)  You do not need to do anything with the  $priority  argument, though we\nrecommend passing it as a default value if you are not specifying a priority for\nany listeners you attach.",
            "title": "ListenerAggregateInterface::attach()"
        },
        {
            "location": "/migration/changed/#filterinterfaceattach-and-detach",
            "text": "Zend\\EventManager\\Filter\\FilterInterface::attach()  and  detach()  have changed\nsignatures. The originals were:  attach($callback) : CallbackHandler\ndetach(CallbackHandler $callback) : bool  where  $callback  for  attach()  could be a callable or a  CallbackHandler . The\nnew signatures are:  attach(callable $callback) : void\ndetach(callable $filter) : bool  Typical usage in v2 was to capture the return value of  attach()  and pass it to detach() , as  attach()  would create a  CallbackHandler  for you to later pass\nto  detach() . Since we can now pass the original callable argument to detach()  now, you can cache that value instead.",
            "title": "FilterInterface::attach() and detach()"
        },
        {
            "location": "/migration/changed/#filteriterator",
            "text": "Zend\\EventManager\\Filter\\FilterIterator  now defines/overrides the  insert() \nmethod in order to validate the incoming value and ensure it is callable,\nraising an exception when it is not. This simplifies logic in  FilterChain , as\nit no longer needs to check if a filter is callable at runtime.  The main migration change at this time is to know that an InvalidArgumentException  will now be thrown when adding filters to a filter\nchain, vs at runtime.",
            "title": "FilterIterator"
        },
        {
            "location": "/migration/changed/#responsecollectionsetstopped",
            "text": "Zend\\EventManager\\ResponseCollection::setStopped()  no longer implements a\nfluent interface.",
            "title": "ResponseCollection::setStopped()"
        }
    ]
}